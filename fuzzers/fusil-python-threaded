#!/usr/bin/env python
"""
Generate Python source code: random function calls with random arguments.
Use "python" command line program.

Interesting modules: all modules written in C or having some code written
in C, see Modules/*.c in Python source code.
"""

import builtins
import datetime
import inspect
import pkgutil
import random
import re
import resource
import sys
import time
import warnings
from optparse import OptionGroup
from os.path import exists as path_exists, isabs, sep as path_sep
from random import choice, randint, sample
from types import BuiltinFunctionType, FunctionType, ModuleType

from ptrace.os_tools import RUNNING_PYTHON3
try:
    import numpy
    print("Numpy is available, using it to build tricky arrays.")
    USE_NUMPY = True
except ImportError:
    print("Numpy is not available.")
    USE_NUMPY = False

try:
    from fusil.python.template_strings import TEMPLATES
    print("Template strings available.")
    USE_TEMPLATE_STRINGS = True
except ImportError:
    print("Template strings not available.")
    USE_TEMPLATE_STRINGS = False


from fusil.application import Application
from fusil.bytes_generator import BytesGenerator
from fusil.process.create import CreateProcess
from fusil.process.stdout import WatchStdout
from fusil.process.watch import WatchProcess
from fusil.project_agent import ProjectAgent
from fusil.python.blacklists import BLACKLIST, METHOD_BLACKLIST, MODULE_BLACKLIST, OBJECT_BLACKLIST
from fusil.python.mangle import mangle_loop, mangle_obj
from fusil.python.tricky_weird import (weird_names, weird_instance_names, weird_classes,
    tricky_typing, tricky_objects_names, tricky_objects, type_names, tricky_numpy_names, tricky_numpy)
from fusil.python.values import BUFFER_OBJECTS, INTERESTING, SURROGATES
from fusil.six import string_types, text_type
from fusil.unicode_generator import (
    ASCII8,
    DECIMAL_DIGITS,
    LETTERS,
    UNICODE_65535,
    IntegerGenerator,
    IntegerRangeGenerator,
    UnicodeGenerator,
    UnixPathGenerator,
    UnsignedGenerator,
)
from fusil.write_code import WriteCode

if not RUNNING_PYTHON3:
    from sys import getfilesystemencoding


# Fuzzer options
IGNORE_TIMEOUT = True
IGNORE_CPU = True
SHOW_STDOUT = False
DEBUG = False

xrange = range

print(sys.version)

# Constants
TIMEOUT = 350.0
PYTHON = sys.executable
FILENAMES = "/etc/machine-id,/bin/sh"
PARSE_PROTOTYPE = True
PROTOTYPE_REGEX = re.compile(r"[A-Za-z]+[A-Za-z_0-9]*\(([^)]*)\)", re.MULTILINE)

# Currently we have to import all C modules before running the fuzzer.
# TODO: figure out why and fix it properly.
for name in sys.stdlib_module_names:
    if name not in MODULE_BLACKLIST and "test" not in name:
        try:
            sys.modules[name] = __import__(name)
        except ImportError as e:
            print("Failed to import module %s\n" % name, e)

if DEBUG:
    NB_CALL = 5
    NB_METHOD = 1
    NB_CLASS = 5
else:
    NB_CALL = 250
    NB_METHOD = 15
    NB_CLASS = 50
MAX_ARG = 6
MAX_VAR_ARG = 5

EXCLUDE_EXCEPTIONS = True
EXCEPTION_NAMES = {
    cls.__name__ for cls in builtins.__dict__.values()
    if isinstance(cls, type) and issubclass(cls, Exception)
}


class ListAllModules:
    def __init__(self, logger, only_c, site_package, blacklist, skip_test):
        self.logger = logger
        self.only_c = only_c
        self.site_package = site_package
        self.blacklist = blacklist
        self.names = set(sys.builtin_module_names) - {"__main__"}
        self.skip_test = skip_test

    def matchModule(self, is_package, name, filename):
        if filename is not None and not self.filter_filename(filename):
            return False
        if not self.only_c:
            return True
        if is_package:
            return False
        if any(
            filename.endswith(ext)
            for ext in (".py", ".pyc", ".pyo")
            if filename is not None
        ):
            return False
        return True

    def filter_filename(self, filename):
        if not self.site_package:
            if "site-packages" in filename.split(path_sep):
                return False
        if name in self.blacklist:
            return False
        return True

    def walk_packages(self, path=None, prefix="", onerror=None):
        def seen(p, m={}):
            if p in m:
                return True
            m[p] = True

        for info in pkgutil.iter_modules(path, prefix):
            path = package = None
            if info.name in sys.modules:
                path = getattr(sys.modules[info.name], "__path__", None)
                package = getattr(sys.modules[info.name], "__package__", None)
            if (
                (self.skip_test and "test" in info.name)
                or "pip" in info.name
                or "logging" in info.name
                or "pydoc" in info.name
                or "tkinter" in info.name
                or (not self.site_package and path is not None and any("site-packages" in p for p in path))
                or (package is not None and "pip" in package)
            ):
                print("SKIPPED", info, file=sys.stderr)
                continue
            print(f"CHECKING {info.name=} {package=} {path=}")
            if not self.is_module_c(info.name, ""):
                continue
            yield info

            if info.ispkg:
                try:
                    __import__(info.name)
                except ImportError:
                    if onerror is not None:
                        onerror(info.name)
                except Exception:
                    if onerror is not None:
                        onerror(info.name)
                    else:
                        raise
                else:
                    if info.name in sys.modules:
                        path = getattr(sys.modules[info.name], "__path__", None) or []
                        # don't traverse path items we've seen before
                        path = [p for p in path if not seen(p)]
                        yield from self.walk_packages(path, info.name + ".", onerror)

    def search_modules(self, path, prefix):
        if path is not None and not self.site_package:
            path = [name for name in path if self.filter_filename(name)]
            if not path:
                return
        try:
            for loader, name, is_package in self.walk_packages(
                None, onerror=lambda x: None
            ):
                if name.endswith("_d"):
                    # Ignore Debian debug modules
                    # (e.g. ignore "_bisect_d", the real module is "_bisect)
                    continue
                if (
                    name in self.blacklist
                    or prefix in self.blacklist
                    or prefix.split(".")[0] in self.blacklist
                    or name.split(".")[0] in self.blacklist
                    or "test" in name
                    or "idlelib" in name
                    or "pydoc" in name
                    or "logging" in name
                ):
                    # Ignore the module and all of its submodules
                    self.logger.error(f"IGNORED {prefix}:{name}")
                    continue
                if not self.is_module_c(name, prefix):
                    continue
                fullname = prefix + name
                self.logger.error(f"ADDING {fullname}: {prefix}+{name}")
                self.names.add(fullname)
        except:
            raise

    def is_module_c(self, name, prefix):
        is_c = True
        fullname = prefix + name
        print(f"TESTING {fullname}")
        if self.only_c:
            module = None
            if fullname in sys.modules:
                module = sys.modules[fullname]
            elif name in sys.modules:
                module = sys.modules[name]
            elif name.split(".")[0] in sys.modules:
                module = sys.modules[name.split(".")[0]]
            elif prefix in sys.modules:
                module = sys.modules[prefix]
            elif prefix.split(".")[0] in sys.modules:
                module = sys.modules[prefix.split(".")[0]]
            else:
                try:
                    module = __import__(fullname)
                except ImportError as e:
                    print(e)
                    pass
            if module and hasattr(module, "__file__"):
                if module.__file__.endswith(("py", "pyo", "pyc", "pyw")):
                    if "__init__" not in module.__file__:
                        is_c = False
                        self.logger.error(f"SKIP PYTHON MODULE {fullname}")
        return is_c

    def search(self):
        self.search_modules(None, "")
        return self.names


class Fuzzer(Application):
    NAME = "python"

    def createFuzzerOptions(self, parser):
        options = OptionGroup(parser, "Python fuzzer")
        options.add_option(
            "--modules",
            help="Tested Python module names separated by commas (default: test all modules)",
            type="str",
            default="*",
        )
        options.add_option(
            "--packages",
            help="Tested Python packages names separated by commas (default: test all packages)",
            type="str",
            default="*",
        )
        options.add_option(
            "--skip-test",
            help="Skip modules with 'test' in the name (default: False)",
            action="store_true",
        )
        options.add_option(
            "--blacklist",
            help='Module blacklist separated by commas (eg. "_lsprof,_json")',
            type="str",
        )
        options.add_option(
            "--test-private",
            help="Test private methods (default: skip privates methods)",
            action="store_true",
        )
        options.add_option(
            "--timeout",
            help="Timeout in seconds (default: %.1f)" % TIMEOUT,
            type="float",
            default=TIMEOUT,
        )
        options.add_option(
            "--filenames",
            help="Names separated by commas of readable files (default: %s)"
            % FILENAMES,
            type="str",
            default=FILENAMES,
        )
        options.add_option(
            "--python",
            help="Python executable program path (default: %s)" % PYTHON,
            type="str",
            default=PYTHON,
        )
        options.add_option(
            "--only-c",
            help="Only search for modules written in C (default: search all module)",
            action="store_true",
        )
        options.add_option(
            "--no-site-packages",
            help="Don't search modules in site-packages directory",
            action="store_true",
        )
        return options

    def setupProject(self):
        project = self.project

        project.error(f"Start time: {time.asctime()}")
        project.error("Use python interpreter: %s" % self.options.python)
        version = " -- ".join(line.strip() for line in sys.version.splitlines())
        project.error("Python version: %s" % version)
        PythonSource(project, self.options)
        process = PythonProcess(
            project,
            [self.options.python, "-u", "<source.py>"],
            timeout=self.options.timeout,
        )
        process.max_memory = 4000 * 1024 * 1024 * 1024 * 1024
        options = {"exitcode_score": 0}
        if IGNORE_TIMEOUT:
            options["timeout_score"] = 0
        watch = WatchProcess(process, **options)
        if watch.cpu and IGNORE_CPU:
            watch.cpu.max_score = 0

        stdout = WatchStdout(process)
        stdout.max_nb_line = None

        # Disable dummy error messages
        stdout.words = {
            "oops": 0.30,
            "bug": 0.10,
            "fatal": 0.1,
            # "assert": 0.025,
            "assertion": 1.0,
            "critical": 1.0,
            "panic": 1.0,
            "glibc detected": 1.0,
            "segfault": 1.0,
            "segmentation fault": 1.0,
            "SystemError": 1.0,
            "AddressSanitizer": 1.0,
        }

        stdout.kill_words = {"MemoryError", "mimalloc"}

        # CPython critical messages
        stdout.addRegex("^XXX undetected error", 1.0)
        stdout.addRegex("Fatal Python error", 1.0)
        # Match "Cannot allocate memory"?

        # PyPy messages
        stdout.addRegex("Fatal RPython error", 1.0)

        if SHOW_STDOUT or DEBUG:
            stdout.show_matching = True
            stdout.show_not_matching = True

        # avoid matching on "assert" keyword
        stdout.ignoreRegex(r"ast\.Assert()")

        # PyPy interact prompt
        # avoid false positive on "# assert did not crash"
        stdout.ignoreRegex(r"^And now for something completely different:")

        # Hide Python warnings on import
        warnings.simplefilter("ignore")

    def exit(self, keep_log=True):
        super().exit(keep_log=keep_log)
        self.error(print_running_time())


ERRBACK_NAME = "errback"

METHODS_NB_ARG = {
    "__abs__": 0,
    "__add__": 1,
    "__aenter__": 0,
    "__aexit__": 0,
    "__aiter__": 0,
    "__and__": 1,
    "__anext__": 0,
    "__await__": 0,
    "__bool__": 0,
    "__buffer__": 1,
    "__bytes__": 0,
    "__ceil__": 0,
    "__class_getitem__": 1,
    "__complex__": 0,
    "__contains__": 1,
    "__copy__": 0,
    "__deepcopy__": 1,
    "__delattr__": 1,
    "__delete__": 1,
    "__delitem__": 1,
    "__dir__": 0,
    "__div__": 1,
    "__divmod__": 1,
    "__enter__": 0,
    "__eq__": 1,
    "__exit__": 3,
    "__float__": 0,
    "__floor__": 1,
    "__floordiv__": 0,
    "__format__": 1,
    "__fspath__": 0,
    "__ge__": 1,
    "__get__": 2,
    "__getattr__": 1,
    "__getattribute__": 1,
    "__getitem__": 1,
    "__getnewargs__": 0,
    "__getnewargs_ex__": 0,
    "__getslice__": 2,
    "__getstate__": 0,
    "__gt__": 1,
    "__hash__": 0,
    "__iadd__": 1,
    "__iand__": 1,
    "__idiv__": 1,
    "__ifloordiv__": 0,
    "__ilshift__": 1,
    "__imatmul__": 1,
    "__imod__": 1,
    "__index__": 0,
    "__init_subclass__": 1,
    "__instancecheck__": 1,
    "__int__": 0,
    "__invert__": 0,
    "__ior__": 1,
    "__irshift__": 1,
    "__isub__": 1,
    "__iter__": 0,
    "__itruediv__": 1,
    "__ixor__": 1,
    "__le__": 1,
    "__len__": 0,
    "__length_hint__": 0,
    "__lshift__": 1,
    "__lt__": 1,
    "__matmul__": 1,
    "__missing__": 1,
    "__mod__": 1,
    "__mro_entries__": 0,
    "__ne__": 1,
    "__neg__": 0,
    "__new__": 3,
    "__next__": 1,
    "__or__": 1,
    "__pos__": 0,
    "__post_init__": 2,
    "__prepare__": 0,
    "__radd__": 1,
    "__rand__": 1,
    "__rdivmod__": 1,
    "__reduce__": 0,
    "__reduce_ex__": (0, 1),
    "__release_buffer__": 1,
    "__replace__": 1,
    "__repr__": 0,
    "__reversed__": 0,
    "__rfloordiv__": 0,
    "__rlshift__": 1,
    "__rmatmul__": 1,
    "__rmod__": 1,
    "__ror__": 1,
    "__round__": 0,
    "__rrshift__": 1,
    "__rshift__": 1,
    "__rsub__": 1,
    "__rtruediv__": 1,
    "__rxor__": 1,
    "__set__": 2,
    "__set_name__": 2,
    "__setattr__": 2,
    "__setitem__": 2,
    "__setstate__": 1,
    "__sizeof__": 0,
    "__str__": 0,
    "__sub__": 1,
    "__subclasscheck__": 1,
    "__subclasshook__": 1,
    "__truediv__": 1,
    "__trunc__": 0,
    "__xor__": 1,
    "abs": 1,
    "add": 1,
    "all": 1,
    "any": 1,
    "append": 1,
    "ascii": 1,
    "bin": 1,
    "callable": 1,
    "chr": 1,
    "clear": 0,
    "close": 0,
    "compile": (3, 6),
    "decode": 0,
    "delattr": 2,
    "dir": 1,
    "divmod": 2,
    "encode": 0,
    "eval": (1, 3),
    "exec": 3,
    "format": (1, 2),
    "get": (1, 2),
    "getattr": (2, 3),
    "getvalue": 0,
    "hasattr": 2,
    "hash": 1,
    "hex": 1,
    "isinstance": 2,
    "issubclass": 2,
    "items": 0,
    "iter": (1, 2),
    "join": 1,
    "keys": 0,
    "len": 1,
    "match": 1,
    "max": (1, 4),
    "min": (1, 4),
    "next": (1, 2),
    "oct": 1,
    "open": (1, 8),
    "ord": 1,
    "pop": (0, 1),
    "read": (0, 1),
    "replace": 2,
    "repr": 1,
    "round": (1, 2),
    "setattr": 3,
    "sort": 0,
    "sorted": 1,
    "split": 1,
    "strip": (0, 1),
    "sum": (1, 2),
    "update": 1,
    "values": 0,
    "write": 1,
}

CLASS_NB_ARG = {
    "bool": (1, 1),
    "bytearray": (0, 3),
    "bytes": (0, 3),
    "classmethod": (1, 1),
    "complex": (0, 2),
    "dict": (0, 1),
    "enumerate": (1, 2),
    "filter": (2, 2),
    "float": (1, 1),
    "frozenset": (0, 1),
    "int": (0, 2),
    "list": (0, 1),
    "map": (2, 5),
    "memoryview": (1, 1),
    "object": (0, 0),
    "property": (1, 4),
    "range": (1, 3),
    "reversed": (1, 1),
    "set": (1, 1),
    "slice": (1, 3),
    "staticmethod": (1, 1),
    "str": (0, 3),
    "super": (1, 2),
    "tuple": (0, 1),
    "type": (0, 3),
    "zip": (1, 3),
}

class PythonFuzzerError(Exception):
    pass


class PythonSource(ProjectAgent):
    def __init__(self, project, options):
        ProjectAgent.__init__(self, project, "python_source")
        self.options = options
        if self.options.modules != "*":
            self.modules = set()
            for module in self.options.modules.split(","):
                module = module.strip()
                if not len(module):
                    continue
                self.modules.add(module)
        else:
            self.error("Search all Python modules...")
            self.modules = ListAllModules(
                self,
                self.options.only_c,
                not self.options.no_site_packages,
                MODULE_BLACKLIST,
                self.options.skip_test,
            ).search()
        if self.options.packages != "*":
            print("\nAdding packages...")
            all_modules = ListAllModules(
                self,
                self.options.only_c,
                not self.options.no_site_packages,
                MODULE_BLACKLIST,
                self.options.skip_test,
            )
            for package in self.options.packages.split(","):
                package = package.strip().strip("/")
                if not len(package):
                    continue
                pack = __import__(package)
                path = pack.__path__[0]
                print(f"Adding package: {package} ({path})")
                package_walker = all_modules.walk_packages([path], package + ".")
                self.modules |= set(mod.name for mod in package_walker)
            print(f"\nKnow modules ({len(self.modules)}): {",".join(sorted(self.modules))}")

        blacklist = self.options.blacklist
        if blacklist:
            blacklist = set(blacklist.split(","))
            removed = self.modules & blacklist
            self.error("Blacklist modules: %s" % removed)
            self.modules = list(self.modules - blacklist)
        self.modules = list(self.modules)
        self.modules.sort()
        self.error("Found %s Python modules" % len(self.modules))
        for name in self.modules:
            self.info("Python module: %s" % name)

        self.filenames = self.options.filenames
        if not RUNNING_PYTHON3:
            encoding = getfilesystemencoding()
            self.filenames = text_type(self.filenames, encoding)
        self.filenames = self.filenames.split(",")
        for filename in self.filenames:
            if not isabs(filename):
                raise ValueError(
                    "Filename %r is not an absolute path! Fix the --filenames option"
                    % filename
                )
            if not path_exists(filename):
                raise ValueError(
                    "File doesn't exist: %s! Use different --filenames option"
                    % filename
                )
        project.error("Use filenames: %s" % ", ".join(self.filenames))
        self.error(print_running_time())

    def loadModule(self, module_name):
        self.module_name = module_name
        self.debug("Import %s" % self.module_name)
        self.module = __import__(self.module_name)
        for name in self.module_name.split(".")[1:]:
            self.module = getattr(self.module, name)
        try:
            self.warning("Module filename: %s" % self.module.__file__)
        except AttributeError:
            pass
        self.write = WritePythonCode(self, self.filename, self.module,
                                     self.module_name, threads=True,
                                     _async=True)

    def on_session_start(self):
        self.filename = self.session().createFilename("source.py")

        # copy sys.modules
        old_sys_modules = sys.modules.copy()

        while self.modules:
            name = choice(self.modules)
            try:
                self.loadModule(name)
                break
            except BaseException as err:
                self.error(
                    "Unable to load module %s: [%s] %s"
                    % (name, err.__class__.__name__, err)
                )
                self.modules.remove(name)
        if not self.modules:
            self.error("There is no more modules!")
            self.send("project_stop")
            return
        self.error("Test module %s" % name)
        self.error(print_running_time())
        self.send("session_rename", name)

        self.write.writeSource()
        self.send("python_source", self.filename)

        # unload new modules
        sys.modules.clear()
        sys.modules.update(old_sys_modules)


class PythonProcess(CreateProcess):
    def on_python_source(self, filename):
        self.cmdline.arguments[-1] = filename
        self.createProcess()


# >'<, >"<, >\<
ESCAPE_CHARACTERS = "'" + '"' + "\\"


def formatCharacter(char):
    if char in ESCAPE_CHARACTERS:
        # >\"<
        return "\\" + char
    code = ord(char)
    if 32 <= code <= 126:
        # >a<
        return char
    elif code <= 255:
        # >\xEF<
        return "\\x%02X" % code
    elif code <= 65535:
        # >\u0101<
        return "\\u%04X" % code
    else:
        # >\U00010FA3<
        return "\\U%08X" % code


def escapeUnicode(text):
    return "".join(formatCharacter(char) for char in text)

USE_MANGLE = False

class WritePythonCode(WriteCode):
    def __init__(self, parent, filename, module, module_name, threads=True, _async=True):
        WriteCode.__init__(self)
        self.filename = filename
        self.filenames = parent.filenames
        self.options = parent.options
        self.threads = threads
        self._async = _async
        self.hashable_argument_generators = (
            self.genNone,
            self.genBool,
            self.genSmallUint,
            self.genSmallUint,
            self.genSmallUint,
            self.genSmallUint,
            self.genSmallUint,
            self.genInt,
            self.genInt,
            self.genInt,
            self.genInt,
            self.genInt,
            self.genInt,
            self.genInt,
            self.genInt,
            self.genLetterDigit,
            self.genBytes,
            self.genBytes,
            self.genBytes,
            self.genBytes,
            self.genBytes,
            self.genBytes,
            self.genBytes,
            self.genBytes,
            self.genBytes,
            self.genBytes,
            self.genBytes,
            self.genBytes,
            self.genBytes,
            self.genBytes,
            self.genBytes,
            self.genBytes,
            self.genString,
            self.genSurrogates,
            self.genAsciiString,
            self.genUnixPath,
            self.genFloat,
            self.genExistingFilename,
            self.genErrback,
            #            self.genOpenFile,
            self.genException,
            self.genRawString,
            self.genWeirdType,
            # self.genWeirdType,
            # self.genWeirdType,
        )
        self.simple_argument_generators = self.hashable_argument_generators + (
            self.genBufferObject,
            self.genInterestingValues,
            self.genWeirdClass,
            # self.genWeirdInstance,
            self.genWeirdInstance,
            self.genWeirdType,
            # self.genWeirdType,
            # self.genWeirdUnion,
            self.genWeirdUnion,
            # self.genTrickyObjects,
            # self.genTrickyObjects,
            self.genTrickyObjects,
        )
        self.complex_argument_generators = (
            self.genList,
            self.genTuple,
            self.genDict,
            self.genTricky,
            self.genInterestingValues,
            self.genWeirdClass,
            self.genWeirdInstance,
            # self.genWeirdInstance,
            self.genWeirdType,
            # self.genWeirdType,
            self.genWeirdUnion,
            # self.genWeirdUnion,
            self.genTrickyObjects,
            # self.genTrickyObjects,
            # self.genTrickyObjects,
        )
        if USE_NUMPY:
            self.complex_argument_generators += (
                self.genTrickyNumpy,
                # self.genTrickyNumpy,
                # self.genTrickyNumpy,
                # self.genTrickyNumpy,
            )
        if USE_TEMPLATE_STRINGS:
            self.complex_argument_generators += (
                self.genTrickyTemplate,
                # self.genTrickyTemplate,
                # self.genTrickyTemplate,
                # self.genTrickyTemplate,
                # self.genTrickyTemplate,
                # self.genTrickyTemplate,
                # self.genTrickyTemplate,
                # self.genTrickyTemplate,
                # self.genTrickyTemplate,
            )
        self.smallint_generator = IntegerRangeGenerator(-19, 19)
        self.int_generator = IntegerGenerator(20)
        self.bytes_generator = BytesGenerator(0, 20)
        self.unicode_generator = UnicodeGenerator(1, 20, UNICODE_65535)
        self.ascii_generator = UnicodeGenerator(0, 20, ASCII8)
        self.unix_path_generator = UnixPathGenerator(100)
        self.letters_generator = UnicodeGenerator(
            1, 8, LETTERS | DECIMAL_DIGITS | ASCII8
        )
        self.float_int_generator = IntegerGenerator(4)
        self.float_float_generator = UnsignedGenerator(4)
        self.module = module
        self.module_name = module_name

        self.functions, self.classes, self.objects = self.getFunctions()
        if not self.functions and not self.classes and not self.objects:
            raise PythonFuzzerError(
                "Module %s has no function, no class and no object!" % self.module_name
            )

    def writePrint(self, level, arguments):
        if RUNNING_PYTHON3:
            code = "print (%s, file=stderr)" % arguments
        else:
            code = "print >>stderr, %s" % arguments
        self.write(level, code)

    def writeSource(self):
        self.createFile(self.filename)
        self.write(0, "from gc import collect")
        self.write(0, "from sys import stderr")
        self.write(0, "import inspect")
        self.write(0, "import sys")
        self.write(0, "from threading import Thread")
        self.write(0, "from unittest.mock import MagicMock")
        self.write(0, "import asyncio")
        if USE_TEMPLATE_STRINGS:
            self.write(0, "from string.templatelib import Interpolation, Template")
        self.writePrint(0, '"import %s"' % self.module_name)
        self.write(0, "import %s" % self.module_name)
        self.emptyLine()
        self.write(0, weird_classes)
        self.emptyLine()
        self.write(0, tricky_typing)
        self.emptyLine()
        self.write(0, tricky_objects)
        self.emptyLine()
        if USE_NUMPY:
            self.write(0, tricky_numpy)
            self.emptyLine()
        self.write(0, "def %s(*args, **kw):" % ERRBACK_NAME)
        self.write(1, "raise ValueError('error')")
        self.emptyLine()
        if self.threads:
            self.write(0, "alive = []")
        if self._async:
            self.write(0, "_async = []")
        self.write(0, "lst = list(range(10))")
        self.write(0, "lst.append(lst)")
        self.write(0, "class Liar1:")
        self.write(1, "def __eq__(self, other):")
        self.write(2, "return True")
        self.emptyLine()
        self.write(0, "class Liar2:")
        self.write(1, "def __eq__(self, other):")
        self.write(2, "return False")
        self.emptyLine()
        self.write(0, "liar1, liar2 = Liar1(), Liar2()")
        self.emptyLine()
        self.write(
            0,
            "\nclass Evil:\n    def __eq__(self, other):\n"
            "        for attr in dir(other):\n"
            "            try:\n"
            "                other.__dict__[attr] = %s\n"
            "            except:\n"
            "                pass\n"
            "evil = Evil()" % ERRBACK_NAME,
        )
        self.emptyLine()
        if USE_MANGLE:
            self.emptyLine()
            self.write(0, mangle_obj)
        self.emptyLine()
        self.write(0, "def callMethod(prefix, object, name, *arguments):")
        level = self.addLevel(1)
        self.writeCallMethod()
        self.restoreLevel(level)
        self.emptyLine()

        self.write(0, "def callFunc(prefix, name, *arguments):")
        self.write(
            1, "return callMethod(prefix, %s, name, *arguments)" % self.module_name
        )
        self.emptyLine()

        self.write(0, "obj = %s" % self.module_name)

        self.writeCode(
            "", self.module, self.functions, self.classes, self.objects, 1, NB_CALL
        )
        self.emptyLine()
        if self.threads:
            self.write(0, "for obj in alive:")
            self.write(1, "try:")
            self.write(2, "print('START', obj)")
            self.write(2, "obj.start()")
            self.write(1, "except Exception:")
            self.write(2, "pass")
            self.write(0, "for obj in alive:")
            self.write(1, "try:")
            self.write(2, "print('JOIN', obj)")
            self.write(2, "obj.join()")
            self.write(1, "except Exception:")
            self.write(2, "pass")
            self.emptyLine()
        if self._async:
            self.write(0, "async def main_async():")
            self.write(1, "await asyncio.gather(*_async, return_exceptions=True)")
            self.emptyLine()
            self.write(0, "runner = asyncio.Runner()")
            self.write(0, "loop = runner.get_loop()")
            self.write(0, "loop.set_task_factory(asyncio.eager_task_factory)")
            self.write(0, "runner.run(main_async())")
            self.emptyLine()
        self.close()

    def writeCallMethod(self):
        self.write(0, 'funcname = "%s.%%s()" %% name' % self.module_name)
        self.write(0, 'message = "[%s] %s" % (prefix, funcname)')
        self.writePrint(0, "message")
        self.write(0, "try:")
        self.write(1, "func = getattr(object, name)")
        self.write(1, "for x in range(5):")
        self.write(2, "result = func(*arguments)")

        exceptions = "(Exception, SystemExit, KeyboardInterrupt)"
        if RUNNING_PYTHON3:
            self.write(0, "except %s as err:" % exceptions)
        else:
            self.write(0, "except %s, err:" % exceptions)
        self.write(1, "try:")
        self.write(2, "errmsg = repr(err)")
        self.write(1, "except ValueError as e:")
        self.write(2, "errmsg = repr(e)")
        if RUNNING_PYTHON3:
            self.write(1, "errmsg = errmsg.encode('ASCII', 'replace')")
        self.writePrint(
            1,
            '"[%s] %s => %s: %s" % (prefix, funcname, err.__class__.__name__, errmsg)',
        )
        self.write(1, "result = None")

        self.writePrint(0, '"[%s] -garbage collector-" % prefix')
        self.write(0, "collect()   # explicit call to the garbage collector")
        if self.threads:
            self.write(0, "try:")
            self.write(1, "if result:")
            self.write(2, "alive.append(Thread(target=func, args=arguments, name=message))")
            self.write(0, "except:")
            self.write(1, "pass")
        self.write(0, "return result")

    def getFunctions(self):
        classes = []
        functions = []
        objects = []
        try:
            blacklist = BLACKLIST[self.module_name]
        except KeyError:
            blacklist = set()
        blacklist |= METHOD_BLACKLIST

        names = set(dir(self.module))
        names -= {"__builtins__", "__doc__", "__file__", "__name__"}
        names -= {"True", "None", "False"}
        if EXCLUDE_EXCEPTIONS:
            names -= EXCEPTION_NAMES
        names -= blacklist
        for name in names:
            try:
                attr = getattr(self.module, name)
            except AttributeError:
                # attribute declared in __all__, but no declared?
                continue
            if isinstance(attr, (FunctionType, BuiltinFunctionType)):
                functions.append(name)
            elif isinstance(attr, type) or inspect.isclass(attr):
                classes.append(name)
            else:
                objects.append(name)
        return functions, classes, objects

    def getMethods(self, object, class_name):
        try:
            key = "%s:%s" % (self.module_name, class_name)
            blacklist = BLACKLIST[key]
        except KeyError:
            blacklist = set()
        blacklist |= METHOD_BLACKLIST
        methods = {}
        if type(object) in {int, str}:
            return methods
        is_exception = isinstance(object, type) and issubclass(object, BaseException)
        is_exception = is_exception or isinstance(object, BaseException)
        for name in dir(object):
            if name in blacklist:
                continue
            if (not self.options.test_private) and name.startswith("__"):
                continue
            if is_exception and name == "__init__":
                continue
            try:
                attr = getattr(object, name, None)
                if attr is None:
                    continue
                if not callable(attr):
                    continue
            except Exception:
                continue
            methods[name] = attr
        return methods

    def _createArgument(self, generators):
        callback = choice(generators)
        value = callback()
        for item in value:
            if not isinstance(item, text_type):
                raise ValueError("%s returned type %s" % (callback, type(item)))
        return value

    def createArgument(self):
        return self._createArgument(self.simple_argument_generators)

    def createHashableArgument(self):
        return self._createArgument(self.hashable_argument_generators)

    def createComplexArgument(self):
        if randint(0, 9) < 9:
            # 10%
            generators = self.complex_argument_generators
        else:
            # 90%
            generators = self.simple_argument_generators
        return self._createArgument(generators)

    def getNbArg(self, func, func_name, min_arg):
        try:
            # Known method of arguments?
            value = METHODS_NB_ARG[func_name]
            if isinstance(value, tuple):
                min_arg, max_arg = value
            else:
                min_arg = max_arg = value
            return min_arg, max_arg
        except KeyError:
            pass

        try:
            argspec = inspect.getfullargspec(func)
            has_self = 1 if "self" in argspec.args or "cls" in argspec.args else 0
            args = (len(argspec.args) - has_self) if argspec.args else 0
            defaults = (len(argspec.defaults) - has_self) if argspec.defaults else 0
            return args - defaults, args
        except TypeError:
            pass

        if PARSE_PROTOTYPE:
            # Try using the documentation
            args = parseDocumentation(func.__doc__, MAX_VAR_ARG)
            if args:
                return args
        return min_arg, MAX_ARG

    def callFunction(self, prefix, func_index, func_name, func, min_arg, obj_name=None):
        if func_name.lower() in {"abort", "systemerror", "fatal", "critical", "assert"}:
            return
        min_arg, max_arg = self.getNbArg(func, func_name, min_arg)

        if randint(0, 19) < 1:
            nb_arg = 0
        elif randint(0, 19) < 2:
            nb_arg = 1
        elif randint(0, 19) < 3:
            nb_arg = max_arg + 1
        elif min_arg == max_arg:
            nb_arg = min_arg
        else:
            nb_arg = randint(min_arg, max_arg)

        if prefix:
            prefix += str(1 + func_index)
            first_line = 'res = callMethod("%s", obj, "%s"' % (prefix, func_name)
        else:
            prefix = "f%s" % (1 + func_index)
            first_line = 'res = callFunc("%s", "%s"' % (prefix, func_name)
        if nb_arg:
            self.write(0, first_line + ",")
            level = self.addLevel(1)
            last_char = ","
            for index in xrange(nb_arg):
                if index == nb_arg - 1:
                    last_char = ")"
                self.writeArgument(1, last_char)
            self.restoreLevel(level)
        else:
            self.write(0, first_line + ")")
        if self.threads:
            self.emptyLine()
            first_line = "alive.append(Thread(target=obj.%s, name='%s', args=(" % (func_name, f"{prefix}:{func_name}")
            self.write(0, "if hasattr(obj, '%s'):" % (func_name,))
            if nb_arg:
                self.write(1, first_line)
                last_char = ","
                for index in xrange(nb_arg):
                    if index == nb_arg - 1:
                        last_char = ",)))"
                    self.writeArgument(1, last_char)
            else:
                self.write(1, first_line + ")))")
        if self._async:
            self.emptyLine()
            self.write(0, "async def %s_%s():" % (prefix, func_name))
            self.write(1, "print('Start async calling %s_%s')" % (prefix, func_name))
            self.write(1, "await asyncio.sleep(%s)" % (random.random() / 100))
            first_line = 'obj.%s(' % func_name
            if nb_arg:
                self.write(1, first_line)
                level = self.addLevel(1)
                last_char = ","
                for index in xrange(nb_arg):
                    if index == nb_arg - 1:
                        last_char = ")"
                    self.writeArgument(1, last_char)
                self.restoreLevel(level)
            else:
                self.write(1, first_line + ")")
            self.write(1, "print('End async calling %s_%s')" % (prefix, func_name))

            self.write(0, "_async.append(%s_%s())" % (prefix, func_name))
        self.emptyLine()

    def writeArgument(self, level, last_char=","):
        lines = self.createComplexArgument()
        lines[-1] += last_char
        for line in lines:
            self.write(level, line)

    def useClass(self, cls_index, cls, class_name):
        import inspect

        if class_name in CLASS_NB_ARG:
            min_args, max_args = CLASS_NB_ARG[class_name]
            nb_arg = randint(min_args, max_args)
        else:
            try:
                argspec = inspect.getfullargspec(cls.__init__)
                args = len(argspec.args) - 1 if argspec.args else 0
                defaults = len(argspec.defaults) if argspec.defaults else 0
                nb_arg = randint(args - defaults, args)
            except TypeError:
                nb_arg = randint(0, 3)

        prefix = "o%s" % (1 + cls_index)
        self.writePrint(0, '"[%s] Create object %s"' % (prefix, 1 + cls_index))

        obj_name = "obj"
        self.write(0, '%s = callFunc("%s", "%s",' % (obj_name, prefix, class_name))
        for index in xrange(nb_arg):
            self.write(2, "# argument %s/%s" % (1 + index, nb_arg))
            self.writeArgument(2)
        self.write(1, ")")
        if USE_MANGLE:
            self.write(0, mangle_loop % nb_arg)
        methods = sorted(self.getMethods(cls, class_name).keys())
        if methods:
            self.write(0, "if obj is not None:")
            level = self.addLevel(1)
            self.writeCode(prefix + "m", cls, methods, tuple(), tuple(), 0, NB_METHOD)
            self.write(0, "del %s" % obj_name)
            self.writePrint(0, '"[%s] -garbage collector -"' % prefix)
            self.write(0, "collect()   # explicit call to the garbage collector")
            self.restoreLevel(level)
        self.emptyLine()

    def useObject(self, obj_index, obj, obj_name):
        prefix = "obj%s" % (1 + obj_index)
        self.writePrint(
            0,
            '"[%s] Call methods on object %s (%s)"' % (prefix, 1 + obj_index, obj_name),
        )
        self.write(0, "obj = %s.%s" % (self.module_name, obj_name))
        methods = self.getMethods(obj, obj_name)
        if methods:
            self.write(0, "if obj is not None:")
            level = self.addLevel(1)
            self.writeCode(
                prefix + "m",
                obj,
                sorted(methods.keys()),
                tuple(),
                tuple(),
                0,
                NB_METHOD,
                obj_name,
            )
            self.writePrint(0, '"[%s] -garbage collector -"' % prefix)
            self.write(0, "collect()   # explicit call to the garbage collector")
            self.restoreLevel(level)
        self.emptyLine()

    def writeCode(
        self,
        prefix,
        object,
        functions,
        classes,
        objects,
        func_min_arg,
        nb_call,
        obj_name=None,
    ):
        if functions:
            for index in xrange(nb_call):
                func_name = choice(functions)
                func = getattr(object, func_name)
                self.callFunction(
                    prefix, index, func_name, func, func_min_arg, obj_name
                )
        if classes:
            self.nb_class = NB_CLASS
            for index in xrange(self.nb_class):
                class_name = choice(classes)
                cls = getattr(object, class_name)
                self.useClass(index, cls, class_name)
        if objects:
            for index in xrange(min(len(objects) * 2, 100)):
                object_name = choice(objects)
                obj = getattr(object, object_name)
                if object_name in OBJECT_BLACKLIST or isinstance(obj, ModuleType):
                    continue
                self.useObject(index, obj, object_name)

    def genNone(self):
        return ["None"]

    def genTricky(self):
        return [
            choice(
                [
                    "liar1",
                    "liar2",
                    # "lst",
                    "lambda *args, **kwargs: 1/0",
                    "int",
                    "type",
                    "object()",
                    "[[[[[[[[[[[[[[]]]]]]]]]]]]]]",
                    "MagicMock()",
                    "Evil()",
                    "MagicMock",
                    "Evil",
                    "Liar1",
                    "Liar2",
                ]
            )
        ]

    def genBool(self):
        if randint(0, 1) == 1:
            return ["True"]
        else:
            return ["False"]

    def genSmallUint(self):
        return [self.smallint_generator.createValue()]

    def genInt(self):
        return [self.int_generator.createValue()]

    def genBytes(self):
        # Bytes string
        bytes = self.bytes_generator.createValue()
        if RUNNING_PYTHON3:
            text = "".join("\\x%02X" % byte for byte in bytes)
            text = 'b"%s"' % text
        else:
            text = "".join("\\x%02X" % ord(byte) for byte in bytes)
            text = '"%s"' % text
        return [text]

    def genUnixPath(self):
        path = self.unix_path_generator.createValue()
        return ['"%s"' % path]

    def _genUnicode(self, generator):
        # (Unicode) character string
        text = generator.createValue()
        text = escapeUnicode(text)
        if RUNNING_PYTHON3:
            text = '"%s"' % text
        else:
            text = 'u"%s"' % text
        return [text]

    def genLetterDigit(self):
        return self._genUnicode(self.letters_generator)

    def genString(self):
        return self._genUnicode(self.unicode_generator)

    def genRawString(self):
        sequences = (
            [r"\d", r"\D", r"\w", r"\W", r"\s", r"\S", r"\b", r"\B", r"\A", r"\Z"]
            + sorted(LETTERS)
            + ["."] * 10
        )
        special = ["+", "?", "*"]
        result = []
        for x in range(randint(3, 20)):
            result.append("".join(sample(sequences, randint(1, 3))))
            if randint(0, 9) > 8:
                result.append(choice(special))
        return [f'r"{"".join(result)}"']

    def genSurrogates(self):
        text = choice(SURROGATES)
        return [text]

    def genInterestingValues(self):
        interesting = choice(INTERESTING)
        return [interesting]

    def genTrickyObjects(self):
        tricky = choice(tricky_objects_names)
        return [tricky]

    def genTrickyNumpy(self):
        tricky = choice(tricky_numpy_names)
        return [tricky]

    def genTrickyTemplate(self):
        tricky = choice(TEMPLATES)
        return [tricky]

    def genWeirdClass(self):
        weird_class_name = choice(weird_names)
        return [f"weird_classes['{weird_class_name}']"]

    def genWeirdInstance(self):
        weird_class_name = choice(weird_instance_names)
        return [f"weird_instances['{weird_class_name}']"]

    def genWeirdType(self):
        weird_class_name = choice(weird_names)
        type_name = choice(type_names)
        return [f"{type_name}[weird_classes['{weird_class_name}']]"]

    def genWeirdUnion(self):
        weird_class_name1 = choice(weird_names)
        weird_class_name2 = choice(weird_names)
        type_name = choice(type_names)
        return [f"{type_name}[weird_classes['{weird_class_name1}']] | weird_classes['{weird_class_name2}'] | big_union"]

    def genBufferObject(self):
        text = choice(BUFFER_OBJECTS)
        return [text]

    def genAsciiString(self):
        return self._genUnicode(self.ascii_generator)

    def genFloat(self):
        int_part = self.float_int_generator.createValue()
        float_part = self.float_float_generator.createValue()
        return ["%s.%s" % (int_part, float_part)]

    def genExistingFilename(self):
        filename = choice(self.filenames)
        return ["'%s'" % filename]

    def genErrback(self):
        return ["%s" % ERRBACK_NAME]

    def genOpenFile(self):
        filename = choice(self.filenames)
        if RUNNING_PYTHON3:
            instr = "open('%s')" % filename
        else:
            instr = "open(u'%s')" % filename
        return [instr]

    def genException(self):
        return ["Exception('pouet')"]

    def _genList(self, open_text, close_text, empty, is_dict=False):
        # 90% of the time generate values of the same type
        same_type = randint(0, 9) != 0
        nb_item = randint(0, 9)
        if not nb_item:
            return [empty]
        items = []
        if same_type:
            if is_dict:
                key_callback = choice(self.hashable_argument_generators)
            value_callback = choice(self.simple_argument_generators)
            for index in xrange(nb_item):
                if is_dict:
                    item = self.createDictItem(key_callback, value_callback)
                else:
                    item = value_callback()
                items.append(item)
        else:
            for index in xrange(nb_item):
                if is_dict:
                    item = self.createDictItem()
                else:
                    item = self.createArgument()
                items.append(item)
        lines = []
        for item_index, item_lines in enumerate(items):
            if item_index:
                lines[-1] += ","
                for index, line in enumerate(item_lines):
                    # Add ' ' suffix to all lines
                    item_lines[index] = " " + line
            lines.extend(item_lines)
        if nb_item == 1 and empty == "tuple()":
            lines[-1] += ","
        lines[0] = open_text + lines[0]
        lines[-1] += close_text
        return lines

    def createDictItem(self, key_callback=None, value_callback=None):
        if key_callback:
            key = key_callback()
        else:
            key = self.createHashableArgument()
        if value_callback:
            value = value_callback()
        else:
            value = self.createArgument()
        key[-1] += ": " + value[0]
        key.extend(value[1:])
        return key

    def genList(self):
        return self._genList("[", "]", "[]")

    def genTuple(self):
        return self._genList("(", ")", "tuple()")

    def genDict(self):
        return self._genList("{", "}", "{}", True)


def parseArguments(arguments, defaults):
    for arg in arguments.split(","):
        arg = arg.strip(" \n[]")
        if not arg:
            continue
        if "=" in arg:
            arg, value = arg.split("=", 1)
            defaults[arg] = value
        yield arg


def parsePrototype(doc):
    r"""
    >>> parsePrototype("test([x])")
    ((), None, ('x',), {})
    >>> parsePrototype('dump(obj, file, protocol=0)')
    (('obj', 'file'), None, ('protocol',), {'protocol': '0'})
    >>> parsePrototype('setitimer(which, seconds[, interval])')
    (('which', 'seconds'), None, ('interval',), {})
    >>> parsePrototype("decompress(string[, wbits[, bufsize]])")
    (('string',), None, ('wbits', 'bufsize'), {})
    >>> parsePrototype("decompress(string,\nwbits)")
    (('string', 'wbits'), None, (), {})
    >>> parsePrototype("get_referents(*objs)")
    ((), '*objs', (), {})
    >>> parsePrototype("nothing")
    """
    if not doc:
        return None
    if not isinstance(doc, string_types):
        return None
    doc = doc.strip()
    match = PROTOTYPE_REGEX.match(doc)
    if not match:
        return None
    arguments = match.group(1)
    if arguments == "...":
        return None
    defaults = {}
    vararg = None
    varkw = tuple()
    if "[" in arguments:
        arguments, varkw = arguments.split("[", 1)
        arguments = tuple(parseArguments(arguments, defaults))
        varkw = tuple(parseArguments(varkw, defaults))
    else:
        arguments = tuple(parseArguments(arguments, defaults))

    # Argument with default value? => varkw
    move = None
    for index in xrange(len(arguments) - 1, -1, -1):
        arg = arguments[index]
        if arg not in defaults:
            break
        move = index
    if move is not None:
        varkw = arguments[move:] + varkw
        arguments = arguments[:move]

    if arguments and arguments[-1].startswith("*"):
        vararg = arguments[-1]
        arguments = arguments[:-1]
    return arguments, vararg, varkw, defaults


def parseDocumentation(doc, max_var_arg):
    """
    Arguments:
     - doc: documentation string
     - max_var_arg: maximum number of arguments for variable argument,
       eg. test(*args).
    """
    prototype = parsePrototype(doc)
    if not prototype:
        return None

    args, varargs, varkw, defaults = prototype
    min_arg = len(args)
    max_arg = min_arg + len(varkw)
    if varargs:
        max_arg += max_var_arg
    return min_arg, max_arg


def remove_logging_pycache():
    """Remove stale logging __pycache__ that causes logging errors."""
    import importlib
    import logging
    import pathlib

    pycache = pathlib.Path(logging.__file__).parent / "__pycache__"
    for entry in pycache.iterdir():
        try:
            entry.unlink()
        except Exception:
            pass
    try:
        pycache.rmdir()
    except Exception:
        pass
    importlib.reload(logging)


def print_running_time():
    raw_utime = resource.getrusage(resource.RUSAGE_SELF).ru_utime
    user_time = str(datetime.timedelta(0, round(raw_utime, 2)))
    total_time = str(datetime.timedelta(0, round(time.time() - time_start, 2)))
    return f"\nRunning time: {total_time[:-4]}\nUser time:    {user_time[:-4]}"

if __name__ == "__main__":
    time_start = time.time()
    remove_logging_pycache()
    Fuzzer().main()
