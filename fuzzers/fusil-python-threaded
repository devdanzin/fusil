#!/usr/bin/env python
"""
Generate Python source code: random function calls with random arguments.
Use "python" command line program.

Interesting modules: all modules written in C or having some code written
in C, see Modules/*.c in Python source code.
"""

import builtins
import datetime
import inspect
import pkgutil
import random
import resource
import sys
import time
import warnings
from optparse import OptionGroup
from os.path import exists as path_exists, isabs, sep as path_sep
from random import choice, randint, sample
from types import BuiltinFunctionType, FunctionType, ModuleType

from ptrace.os_tools import RUNNING_PYTHON3

import fusil.python.tricky_weird
from fusil.application import Application
from fusil.bytes_generator import BytesGenerator
from fusil.config import createFilename
from fusil.process.create import CreateProcess
from fusil.process.stdout import WatchStdout
from fusil.process.watch import WatchProcess
from fusil.project_agent import ProjectAgent
from fusil.python.arg_numbers import get_arg_number, class_arg_number
from fusil.python.blacklists import BLACKLIST, METHOD_BLACKLIST, MODULE_BLACKLIST, OBJECT_BLACKLIST
from fusil.python.mangle import mangle_loop, mangle_obj
from fusil.python.unicode import escapeUnicode
from fusil.python.values import BUFFER_OBJECTS, INTERESTING, SURROGATES
from fusil.six import text_type
from fusil.unicode_generator import (
    ASCII8,
    DECIMAL_DIGITS,
    LETTERS,
    UNICODE_65535,
    IntegerGenerator,
    IntegerRangeGenerator,
    UnicodeGenerator,
    UnixPathGenerator,
    UnsignedGenerator,
)
from fusil.write_code import WriteCode

if not RUNNING_PYTHON3:
    from sys import getfilesystemencoding

try:
    import numpy
    print("Numpy is available, using it to build tricky arrays.")
    USE_NUMPY = True
except ImportError:
    print("Numpy is not available.")
    USE_NUMPY = False

try:
    from fusil.python.template_strings import TEMPLATES
    print("Template strings available.")
    USE_TEMPLATE_STRINGS = True
except ImportError:
    print("Template strings not available.")
    USE_TEMPLATE_STRINGS = False

print(sys.version)

# Fuzzer options
IGNORE_TIMEOUT = True
IGNORE_CPU = True
SHOW_STDOUT = False
DEBUG = False
USE_MANGLE = False
TIMEOUT = 900.0

xrange = range

# Constants
PYTHON = sys.executable
FILENAMES = "/etc/machine-id,/bin/sh"
DEFAULT_NB_CALL = 250
DEFAULT_NB_METHOD = 15
DEFAULT_NB_CLASS = 50
DEFAULT_NB_OBJ = 100
ERRBACK_NAME = "errback"

EXCEPTION_NAMES = {
    cls.__name__ for cls in builtins.__dict__.values()
    if isinstance(cls, type) and issubclass(cls, Exception)
}


def import_all():
    # Currently we have to import all C modules before running the fuzzer.
    # TODO: figure out why and fix it properly.
    for name in sys.stdlib_module_names:
        if name not in MODULE_BLACKLIST and "test" not in name:
            try:
                sys.modules[name] = __import__(name)
            except ImportError as e:
                print("Failed to import module %s\n" % name, e)


class PythonFuzzerError(Exception):
    pass


class ListAllModules:
    def __init__(self, logger, only_c, site_package, blacklist, skip_test):
        self.logger = logger
        self.only_c = only_c
        self.site_package = site_package
        self.blacklist = blacklist
        self.names = set(sys.builtin_module_names) - {"__main__"}
        self.skip_test = skip_test

    def matchModule(self, is_package, name, filename):
        if filename is not None and not self.filter_filename(filename):
            return False
        if not self.only_c:
            return True
        if is_package:
            return False
        if any(
            filename.endswith(ext)
            for ext in (".py", ".pyc", ".pyo")
            if filename is not None
        ):
            return False
        return True

    def filter_filename(self, filename):
        name_parts = filename.split(path_sep)
        if not self.site_package:
            if "site-packages" in name_parts:
                return False
        if name_parts[-1] in self.blacklist:
            return False
        return True

    def walk_packages(self, path=None, prefix="", onerror=None):
        def seen(p, m={}):
            if p in m:
                return True
            m[p] = True

        for info in pkgutil.iter_modules(path, prefix):
            path = package = None
            if info.name in sys.modules:
                path = getattr(sys.modules[info.name], "__path__", None)
                package = getattr(sys.modules[info.name], "__package__", None)
            if (
                (self.skip_test and "test" in info.name)
                or "pip" in info.name
                or "logging" in info.name
                or "pydoc" in info.name
                or "tkinter" in info.name
                or (not self.site_package and path is not None and any("site-packages" in p for p in path))
                or (package is not None and "pip" in package)
            ):
                print("SKIPPED", info, file=sys.stderr)
                continue
            # print(f"CHECKING {info.name=} {package=} {path=}")
            if not self.is_module_c(info.name, ""):
                continue
            yield info

            if info.ispkg:
                try:
                    __import__(info.name)
                except ImportError:
                    if onerror is not None:
                        onerror(info.name)
                except Exception:
                    if onerror is not None:
                        onerror(info.name)
                    else:
                        raise
                else:
                    if info.name in sys.modules:
                        path = getattr(sys.modules[info.name], "__path__", None) or []
                        # don't traverse path items we've seen before
                        path = [p for p in path if not seen(p)]
                        yield from self.walk_packages(path, info.name + ".", onerror)

    def search_modules(self, path, prefix):
        if path is not None and not self.site_package:
            path = [name for name in path if self.filter_filename(name)]
            if not path:
                return
        try:
            for loader, name, is_package in self.walk_packages(
                None, onerror=lambda x: None
            ):
                if name.endswith("_d"):
                    # Ignore Debian debug modules
                    # (e.g. ignore "_bisect_d", the real module is "_bisect)
                    continue
                if (
                    name in self.blacklist
                    or prefix in self.blacklist
                    or prefix.split(".")[0] in self.blacklist
                    or name.split(".")[0] in self.blacklist
                    or "test" in name
                    or "idlelib" in name
                    or "pydoc" in name
                    or "logging" in name
                ):
                    # Ignore the module and all of its submodules
                    self.logger.error(f"IGNORED {prefix}:{name}")
                    continue
                if not self.is_module_c(name, prefix):
                    continue
                fullname = prefix + name
                self.logger.error(f"ADDING {fullname}: {prefix}+{name}")
                self.names.add(fullname)
        except:
            raise

    def is_module_c(self, name, prefix):
        is_c = True
        fullname = prefix + name
        # print(f"TESTING {fullname}")
        if self.only_c:
            module = None
            if fullname in sys.modules:
                module = sys.modules[fullname]
            elif name in sys.modules:
                module = sys.modules[name]
            elif name.split(".")[0] in sys.modules:
                module = sys.modules[name.split(".")[0]]
            elif prefix in sys.modules:
                module = sys.modules[prefix]
            elif prefix.split(".")[0] in sys.modules:
                module = sys.modules[prefix.split(".")[0]]
            else:
                try:
                    module = __import__(fullname)
                except ImportError as e:
                    print(e)
                    pass
            if module and hasattr(module, "__file__"):
                if module.__file__.endswith(("py", "pyo", "pyc", "pyw")):
                    if "__init__" not in module.__file__:
                        is_c = False
                        self.logger.error(f"SKIP PYTHON MODULE {fullname}")
        return is_c

    def search(self):
        self.search_modules(None, "")
        return self.names


class Fuzzer(Application):
    NAME = "python"

    def createFuzzerOptions(self, parser):
        input_options = OptionGroup(parser, "Input")
        input_options.add_option(
            "--modules",
            help="Tested Python module names separated by commas (default: test all modules)",
            type="str",
            default="*",
        )
        input_options.add_option(
            "--packages",
            help="Tested Python packages names separated by commas (default: test all packages)",
            type="str",
            default="*",
        )
        input_options.add_option(
            "--skip-test",
            help="Skip modules with 'test' in the name (default: False)",
            action="store_true",
            default=False,
        )
        input_options.add_option(
            "--blacklist",
            help='Module blacklist separated by commas (eg. "_lsprof,_json")',
            type="str",
            default="",
        )
        input_options.add_option(
            "--test-private",
            help="Test private methods (default: skip privates methods)",
            action="store_true",
            default=False,
        )
        input_options.add_option(
            "--only-c",
            help="Only search for modules written in C (default: search all module)",
            action="store_true",
            default=False,
        )
        input_options.add_option(
            "--no-site-packages",
            help="Don't search modules in site-packages directory",
            action="store_true",
            default=False,
        )
        running_options = OptionGroup(parser, "Running")
        running_options.add_option(
            "--timeout",
            help="Timeout in seconds (default: %d)" % TIMEOUT,
            type="float",
            default=TIMEOUT,
        )
        running_options.add_option(
            "--python",
            help="Python executable program path (default: %s)" % PYTHON,
            type="str",
            default=PYTHON,
        )
        running_options.add_option(
            "--record-timeouts",
            help="Consider timeouts as errors (default: False)",
            action="store_true",
            default=False,
        )
        running_options.add_option(
            "--record-high-cpu",
            help="Consider high CPU usage an error (default: False)",
            action="store_true",
            default=False,
        )
        running_options.add_option(
            "--show-stdout",
            help="Display STDOUT (default: False)",
            action="store_true",
            default=False,
        )
        fuzzing_options = OptionGroup(parser, "Fuzzing")
        fuzzing_options.add_option(
            "--functions-number",
            help="Number of function calls to generate per module (default: %d)" % DEFAULT_NB_CALL,
            type="int",
            default=DEFAULT_NB_CALL,
        )
        fuzzing_options.add_option(
            "--methods-number",
            help="Number of method calls to create for each class or object (default: %d)" % DEFAULT_NB_METHOD,
            type="int",
            default=DEFAULT_NB_METHOD,
        )
        fuzzing_options.add_option(
            "--classes-number",
            help="Number of classes to fuzz per module (default: %d)" % DEFAULT_NB_CLASS,
            type="int",
            default=DEFAULT_NB_CLASS,
        )
        fuzzing_options.add_option(
            "--objects-number",
            help="Number of objects to fuzz per module (default: %d)" % DEFAULT_NB_OBJ,
            type="int",
            default=DEFAULT_NB_OBJ,
        )
        # options.add_option(
        #     "--no-mangle",
        #     help="Don't mangle objects (default: False)",
        #     action="store_true",
        # )
        fuzzing_options.add_option(
            "--fuzz-exceptions",
            help="Include basic Exceptions in fuzzing (default: False)",
            action="store_true",
            default=False,
        )
        fuzzing_options.add_option(
            "--no-async",
            help="Don't run code asynchronously (default: False)",
            action="store_true",
            default=False,
        )
        fuzzing_options.add_option(
            "--no-threads",
            help="Don't run code in threads (default: False)",
            action="store_true",
            default=False,
        )
        fuzzing_options.add_option(
            "--no-numpy",
            help="Don't use Numpy (default: False)",
            action="store_true",
            default=False,
        )
        fuzzing_options.add_option(
            "--no-tstrings",
            help="Don't use template strings (default: False)",
            action="store_true",
            default=False,
        )
        fuzzing_options.add_option(
            "--filenames",
            help="Names separated by commas of readable files (default: %s)"
            % FILENAMES,
            type="str",
            default=FILENAMES,
        )
        config_options = OptionGroup(parser, "Configuration")
        config_options.add_option(
            "--write-config",
            help="Write a sample configuration file if one doesn't exist (default: %s)" % createFilename(),
            action="store_true",
            default=False,
        )
        return input_options, running_options, fuzzing_options

    def setupProject(self):
        project = self.project

        project.error(f"Start time: {time.asctime()}")
        project.error("Use python interpreter: %s" % self.options.python)
        version = " -- ".join(line.strip() for line in sys.version.splitlines())
        project.error("Python version: %s" % version)
        PythonSource(project, self.options)
        process = PythonProcess(
            project,
            [self.options.python, "-u", "<source.py>"],
            timeout=self.options.timeout,
        )
        process.max_memory = 4000 * 1024 * 1024 * 1024 * 1024
        options = {"exitcode_score": 0}
        if not self.options.record_timeouts:
            options["timeout_score"] = 0
        watch = WatchProcess(process, **options)
        if watch.cpu and not self.options.record_high_cpu:
            watch.cpu.max_score = 0

        stdout = WatchStdout(process)
        stdout.max_nb_line = None

        # Disable dummy error messages
        stdout.words = {
            "oops": 0.30,
            "bug": 0.10,
            "fatal": 0.1,
            # "assert": 0.025,
            "assertion": 1.0,
            "critical": 1.0,
            "panic": 1.0,
            "panicked": 1.0,  # For Rust errors
            "glibc detected": 1.0,
            "segfault": 1.0,
            "segmentation fault": 1.0,
            "SystemError": 1.0,
            "AddressSanitizer": 1.0,
        }

        stdout.kill_words = {"MemoryError", "mimalloc"}

        # CPython critical messages
        stdout.addRegex("^XXX undetected error", 1.0)
        stdout.addRegex("Fatal Python error", 1.0)
        # Match "Cannot allocate memory"?

        # PyPy messages
        stdout.addRegex("Fatal RPython error", 1.0)

        if self.options.show_stdout or self.options.debug:
            stdout.show_matching = True
            stdout.show_not_matching = True

        # avoid matching on "assert" keyword
        stdout.ignoreRegex(r"ast\.Assert()")

        # PyPy interact prompt
        # avoid false positive on "# assert did not crash"
        stdout.ignoreRegex(r"^And now for something completely different:")

        # Hide Python warnings on import
        warnings.simplefilter("ignore")

    def exit(self, keep_log=True):
        super().exit(keep_log=keep_log)
        self.error(print_running_time())


class PythonSource(ProjectAgent):
    def __init__(self, project, options):
        ProjectAgent.__init__(self, project, "python_source")
        self.options = options
        if self.options.modules != "*":
            self.modules = set()
            for module in self.options.modules.split(","):
                module = module.strip()
                if not len(module):
                    continue
                self.modules.add(module)
        else:
            self.error("Search all Python modules...")
            self.modules = ListAllModules(
                self,
                self.options.only_c,
                not self.options.no_site_packages,
                MODULE_BLACKLIST,
                self.options.skip_test,
            ).search()
        if self.options.packages != "*":
            print("\nAdding packages...")
            all_modules = ListAllModules(
                self,
                self.options.only_c,
                not self.options.no_site_packages,
                MODULE_BLACKLIST,
                self.options.skip_test,
            )
            for package in self.options.packages.split(","):
                package = package.strip().strip("/")
                if not len(package):
                    continue
                pack = __import__(package)
                path = pack.__path__[0]
                print(f"Adding package: {package} ({path})")
                package_walker = all_modules.walk_packages([path], package + ".")
                self.modules |= set(mod.name for mod in package_walker)
            print(f"\nKnow modules ({len(self.modules)}): {",".join(sorted(self.modules))}")

        blacklist = self.options.blacklist
        if blacklist:
            blacklist = set(blacklist.split(","))
            removed = self.modules & blacklist
            self.error("Blacklist modules: %s" % removed)
            self.modules = list(self.modules - blacklist)
        self.modules = list(self.modules)
        self.modules.sort()
        self.error("Found %s Python modules" % len(self.modules))
        for name in self.modules:
            self.info("Python module: %s" % name)

        self.filenames = self.options.filenames
        if not RUNNING_PYTHON3:
            encoding = getfilesystemencoding()
            self.filenames = text_type(self.filenames, encoding)
        self.filenames = self.filenames.split(",")
        for filename in self.filenames:
            if not isabs(filename):
                raise ValueError(
                    "Filename %r is not an absolute path! Fix the --filenames option"
                    % filename
                )
            if not path_exists(filename):
                raise ValueError(
                    "File doesn't exist: %s! Use different --filenames option"
                    % filename
                )
        project.error("Use filenames: %s" % ", ".join(self.filenames))
        self.error(print_running_time())

    def loadModule(self, module_name):
        self.module_name = module_name
        self.debug("Import %s" % self.module_name)
        self.module = __import__(self.module_name)
        for name in self.module_name.split(".")[1:]:
            self.module = getattr(self.module, name)
        try:
            self.warning("Module filename: %s" % self.module.__file__)
        except AttributeError:
            pass
        self.write = WritePythonCode(self, self.filename, self.module,
                                     self.module_name, threads=not self.options.no_threads,
                                     _async=not self.options.no_async)

    def on_session_start(self):
        self.filename = self.createFilename("source.py")

        # copy sys.modules
        old_sys_modules = sys.modules.copy()

        name = "NO_MODULES!"
        while self.modules:
            name = choice(self.modules)
            try:
                self.loadModule(name)
                break
            except BaseException as err:
                self.error(
                    "Unable to load module %s: [%s] %s"
                    % (name, err.__class__.__name__, err)
                )
                self.modules.remove(name)
        if not self.modules:
            self.error("There are no more modules!")
            self.send("project_stop")
            return
        self.error("Test module %s" % name)
        self.error(print_running_time())
        self.send("session_rename", name)

        self.write.writeSource()
        self.send("python_source", self.filename)

        # unload new modules
        sys.modules.clear()
        sys.modules.update(old_sys_modules)


class PythonProcess(CreateProcess):
    def on_python_source(self, filename):
        self.cmdline.arguments[-1] = filename
        self.createProcess()


class WritePythonCode(WriteCode):
    def __init__(self, parent, filename, module, module_name, threads=True, _async=True):
        WriteCode.__init__(self)
        self.filename = filename
        self.filenames = parent.filenames
        self.options = parent.options
        self.threads = threads
        self._async = _async
        self.hashable_argument_generators = (
            self.genNone,
            self.genBool,
            self.genSmallUint,
            self.genInt,
            self.genLetterDigit,
            self.genBytes,
            self.genString,
            self.genSurrogates,
            self.genAsciiString,
            self.genUnixPath,
            self.genFloat,
            self.genExistingFilename,
            self.genErrback,
            #            self.genOpenFile,
            self.genException,
            self.genRawString,
            self.genWeirdType,
        )
        self.simple_argument_generators = self.hashable_argument_generators + (
            self.genBufferObject,
            self.genInterestingValues,
            self.genWeirdClass,
            self.genWeirdInstance,
            self.genWeirdType,
            self.genWeirdUnion,
            self.genTrickyObjects,
        )
        self.complex_argument_generators = (
            self.genList,
            self.genTuple,
            self.genDict,
            self.genTricky,
            self.genInterestingValues,
            self.genWeirdClass,
            self.genWeirdInstance,
            self.genWeirdType,
            self.genWeirdUnion,
            self.genTrickyObjects,
        )
        if not self.options.no_numpy and USE_NUMPY:
            self.complex_argument_generators += (
                self.genTrickyNumpy,
            )
        if not self.options.no_tstrings and USE_TEMPLATE_STRINGS:
            self.complex_argument_generators += (
                self.genTrickyTemplate,
            )
        self.smallint_generator = IntegerRangeGenerator(-19, 19)
        self.int_generator = IntegerGenerator(20)
        self.bytes_generator = BytesGenerator(0, 20)
        self.unicode_generator = UnicodeGenerator(1, 20, UNICODE_65535)
        self.ascii_generator = UnicodeGenerator(0, 20, ASCII8)
        self.unix_path_generator = UnixPathGenerator(100)
        self.letters_generator = UnicodeGenerator(
            1, 8, LETTERS | DECIMAL_DIGITS | ASCII8
        )
        self.float_int_generator = IntegerGenerator(4)
        self.float_float_generator = UnsignedGenerator(4)
        self.module = module
        self.module_name = module_name

        self.functions, self.classes, self.objects = self.getFunctions()
        if not self.functions and not self.classes and not self.objects:
            raise PythonFuzzerError(
                "Module %s has no function, no class and no object!" % self.module_name
            )

    def writePrint(self, level, arguments):
        if RUNNING_PYTHON3:
            code = "print (%s, file=stderr)" % arguments
        else:
            code = "print >>stderr, %s" % arguments
        self.write(level, code)

    def writeSource(self):
        self.createFile(self.filename)
        self.write(0, "from gc import collect")
        self.write(0, "from sys import stderr")
        self.write(0, "import inspect")
        self.write(0, "import time")
        self.write(0, "import sys")
        self.write(0, "from threading import Thread")
        self.write(0, "from unittest.mock import MagicMock")
        self.write(0, "import asyncio")
        if not self.options.no_tstrings and USE_TEMPLATE_STRINGS:
            self.write(0, "from string.templatelib import Interpolation, Template")
        self.writePrint(0, '"import %s"' % self.module_name)
        self.write(0, "import %s" % self.module_name)
        self.emptyLine()
        self.write(0, fusil.python.tricky_weird.weird_classes)
        self.emptyLine()
        self.write(0, fusil.python.tricky_weird.tricky_typing)
        self.emptyLine()
        self.write(0, fusil.python.tricky_weird.tricky_objects)
        self.emptyLine()
        if not self.options.no_numpy and USE_NUMPY:
            self.write(0, fusil.python.tricky_weird.tricky_numpy)
            self.emptyLine()
        self.write(0, "def %s(*args, **kw):" % ERRBACK_NAME)
        self.write(1, "raise ValueError('error')")
        self.emptyLine()
        if self.threads:
            self.write(0, "alive = []")
        if self._async:
            self.write(0, "_async = []")
        self.write(0, "lst = list(range(10))")
        self.write(0, "lst.append(lst)")
        self.write(0, "class Liar1:")
        self.write(1, "def __eq__(self, other):")
        self.write(2, "return True")
        self.emptyLine()
        self.write(0, "class Liar2:")
        self.write(1, "def __eq__(self, other):")
        self.write(2, "return False")
        self.emptyLine()
        self.write(0, "liar1, liar2 = Liar1(), Liar2()")
        self.emptyLine()
        self.write(
            0,
            "\nclass Evil:\n    def __eq__(self, other):\n"
            "        for attr in dir(other):\n"
            "            try:\n"
            "                other.__dict__[attr] = %s\n"
            "            except:\n"
            "                pass\n"
            "evil = Evil()" % ERRBACK_NAME,
        )
        self.emptyLine()
        if USE_MANGLE:
            self.emptyLine()
            self.write(0, mangle_obj)
        self.emptyLine()
        self.write(0, "def callMethod(prefix, object, name, *arguments):")
        level = self.addLevel(1)
        self.writeCallMethod()
        self.restoreLevel(level)
        self.emptyLine()

        self.write(0, "def callFunc(prefix, name, *arguments):")
        self.write(
            1, "return callMethod(prefix, %s, name, *arguments)" % self.module_name
        )
        self.emptyLine()

        self.write(0, "obj = %s" % self.module_name)

        self.writeCode(
            "", self.module, self.functions, self.classes, self.objects, 1, self.options.functions_number,
        )
        self.emptyLine()
        if self.threads:
            self.write(0, "for obj in alive:")
            self.write(1, "try:")
            self.write(2, "print('START', obj)")
            self.write(2, "obj.start()")
            self.write(1, "except Exception:")
            self.write(2, "pass")
            self.write(0, "for obj in alive:")
            self.write(1, "try:")
            self.write(2, "print('JOIN', obj)")
            self.write(2, "obj.join()")
            self.write(1, "except Exception:")
            self.write(2, "pass")
            self.emptyLine()
        if self._async:
            self.write(0, "async def main_async():")
            self.write(1, "await asyncio.gather(*[asyncio.to_thread(x) for x in _async], return_exceptions=True)")
            self.emptyLine()
            self.write(0, "runner = asyncio.Runner()")
            self.write(0, "loop = runner.get_loop()")
            # self.write(0, "loop.set_task_factory(asyncio.eager_task_factory)")
            self.write(0, "runner.run(main_async())")
            self.emptyLine()
        self.close()

    def writeCallMethod(self):
        self.write(0, 'funcname = "%s.%%s()" %% name' % self.module_name)
        self.write(0, 'message = "[%s] %s" % (prefix, funcname)')
        self.writePrint(0, "message")
        self.write(0, "try:")
        self.write(1, "func = getattr(object, name)")
        self.write(1, "for x in range(65):")
        self.write(2, "result = func(*arguments)")

        exceptions = "(Exception, SystemExit, KeyboardInterrupt)"
        if RUNNING_PYTHON3:
            self.write(0, "except %s as err:" % exceptions)
        else:
            self.write(0, "except %s, err:" % exceptions)
        self.write(1, "try:")
        self.write(2, "errmsg = repr(err)")
        self.write(1, "except ValueError as e:")
        self.write(2, "errmsg = repr(e)")
        if RUNNING_PYTHON3:
            self.write(1, "errmsg = errmsg.encode('ASCII', 'replace')")
        self.writePrint(
            1,
            '"[%s] %s => %s: %s" % (prefix, funcname, err.__class__.__name__, errmsg)',
        )
        self.write(1, "result = None")

        self.writePrint(0, '"[%s] -garbage collector-" % prefix')
        self.write(0, "collect()   # explicit call to the garbage collector")
        if self.threads:
            self.write(0, "try:")
            self.write(1, "if result:")
            self.write(2, "alive.append(Thread(target=func, args=arguments, name=message))")
            self.write(0, "except:")
            self.write(1, "pass")
        self.write(0, "return result")

    def getFunctions(self):
        classes = []
        functions = []
        objects = []
        try:
            blacklist = BLACKLIST[self.module_name]
        except KeyError:
            blacklist = set()
        blacklist |= METHOD_BLACKLIST

        names = set(dir(self.module))
        names -= {"__builtins__", "__doc__", "__file__", "__name__"}
        names -= {"True", "None", "False"}
        if not self.options.fuzz_exceptions:
            # We could filter all Exception subclasses and instances from the set
            names -= EXCEPTION_NAMES
        names -= blacklist
        for name in names:
            try:
                attr = getattr(self.module, name)
            except AttributeError:
                # attribute listed in __all__, but not declared in the module?
                continue
            if isinstance(attr, (FunctionType, BuiltinFunctionType)):
                functions.append(name)
            elif isinstance(attr, type) or inspect.isclass(attr):
                classes.append(name)
            else:
                objects.append(name)
        return functions, classes, objects

    def getMethods(self, object, class_name):
        try:
            key = "%s:%s" % (self.module_name, class_name)
            blacklist = BLACKLIST[key]
        except KeyError:
            blacklist = set()
        blacklist |= METHOD_BLACKLIST
        methods = {}
        if type(object) in {int, str}:
            return methods
        is_exception = isinstance(object, type) and issubclass(object, BaseException)
        is_exception = is_exception or isinstance(object, BaseException)
        for name in dir(object):
            if name in blacklist:
                continue
            if (not self.options.test_private) and name.startswith("__"):
                continue
            if is_exception and name == "__init__":
                continue
            try:
                attr = getattr(object, name, None)
                if attr is None:
                    continue
                if not callable(attr):
                    continue
            except Exception:
                continue
            methods[name] = attr
        return methods

    def _createArgument(self, generators):
        callback = choice(generators)
        value = callback()
        for item in value:
            if not isinstance(item, text_type):
                raise ValueError("%s returned type %s" % (callback, type(item)))
        return value

    def createArgument(self):
        return self._createArgument(self.simple_argument_generators)

    def createHashableArgument(self):
        return self._createArgument(self.hashable_argument_generators)

    def createComplexArgument(self):
        if randint(0, 9) < 9:
            # 10%
            generators = self.complex_argument_generators
        else:
            # 90%
            generators = self.simple_argument_generators
        return self._createArgument(generators)

    def callFunction(self, prefix, func_index, func_name, func, min_arg, obj_name=None):
        if func_name.lower() in {"abort", "systemerror", "fatal", "critical", "assert"}:
            return
        min_arg, max_arg = get_arg_number(func, func_name, min_arg)

        if randint(0, 19) < 1:
            nb_arg = 0
        elif randint(0, 19) < 2:
            nb_arg = 1
        elif randint(0, 19) < 3:
            nb_arg = max_arg + 1
        elif min_arg == max_arg:
            nb_arg = min_arg
        else:
            nb_arg = randint(min_arg, max_arg)

        if prefix:
            prefix += str(1 + func_index)
            first_line = 'res = callMethod("%s", obj, "%s"' % (prefix, func_name)
        else:
            prefix = "f%s" % (1 + func_index)
            first_line = 'res = callFunc("%s", "%s"' % (prefix, func_name)
        if nb_arg:
            self.write(0, first_line + ",")
            level = self.addLevel(1)
            last_char = ","
            for index in xrange(nb_arg):
                if index == nb_arg - 1:
                    last_char = ")"
                self.writeArgument(1, last_char)
            self.restoreLevel(level)
        else:
            self.write(0, first_line + ")")
        if self.threads:
            self.emptyLine()
            first_line = "alive.append(Thread(target=obj.%s, name='%s', args=(" % (func_name, f"{prefix}:{func_name}")
            self.write(0, "if hasattr(obj, '%s'):" % (func_name,))
            if nb_arg:
                self.write(1, first_line)
                last_char = ","
                for index in xrange(nb_arg):
                    if index == nb_arg - 1:
                        last_char = ",)))"
                    self.writeArgument(1, last_char)
            else:
                self.write(1, first_line + ")))")
        if self._async:
            self.emptyLine()
            self.write(0, "def %s_%s():" % (prefix, func_name))
            self.write(1, "print('Start async calling %s_%s')" % (prefix, func_name))
            self.write(1, "time.sleep(%s)" % (random.random() / 100))
            # self.write(1, "await asyncio.sleep(%s)" % (random.random() / 100))
            first_line = 'try: obj.%s(' % func_name
            if nb_arg:
                self.write(1, first_line)
                level = self.addLevel(1)
                last_char = ","
                for index in xrange(nb_arg):
                    if index == nb_arg - 1:
                        last_char = ")"
                    self.writeArgument(1, last_char)
                self.restoreLevel(level)
            else:
                self.write(1, first_line + ")")
            self.write(1, "except Exception: pass")
            self.write(1, "print('End async calling %s_%s')" % (prefix, func_name))

            self.write(0, "_async.append(%s_%s)" % (prefix, func_name))
        self.emptyLine()

    def writeArgument(self, level, last_char=","):
        lines = self.createComplexArgument()
        lines[-1] += last_char
        for line in lines:
            self.write(level, line)

    def useClass(self, cls_index, cls, class_name):
        nb_arg = class_arg_number(class_name, cls)

        prefix = "o%s" % (1 + cls_index)
        self.writePrint(0, '"[%s] Create object %s"' % (prefix, 1 + cls_index))

        obj_name = "obj"
        self.write(0, '%s = callFunc("%s", "%s",' % (obj_name, prefix, class_name))
        for index in xrange(nb_arg):
            self.write(2, "# argument %s/%s" % (1 + index, nb_arg))
            self.writeArgument(2)
        self.write(1, ")")
        if USE_MANGLE:
            self.write(0, mangle_loop % nb_arg)
        methods = sorted(self.getMethods(cls, class_name).keys())
        if methods:
            self.write(0, "if obj is not None:")
            level = self.addLevel(1)
            self.writeCode(prefix + "m", cls, methods, tuple(), tuple(), 0, self.options.methods_number)
            self.write(0, "del %s" % obj_name)
            self.writePrint(0, '"[%s] -garbage collector -"' % prefix)
            self.write(0, "collect()   # explicit call to the garbage collector")
            self.restoreLevel(level)
        self.emptyLine()

    def useObject(self, obj_index, obj, obj_name):
        prefix = "obj%s" % (1 + obj_index)
        self.writePrint(
            0,
            '"[%s] Call methods on object %s (%s)"' % (prefix, 1 + obj_index, obj_name),
        )
        self.write(0, "obj = %s.%s" % (self.module_name, obj_name))
        methods = self.getMethods(obj, obj_name)
        if methods:
            self.write(0, "if obj is not None:")
            level = self.addLevel(1)
            self.writeCode(
                prefix + "m",
                obj,
                sorted(methods.keys()),
                tuple(),
                tuple(),
                0,
                self.options.methods_number,
                obj_name,
            )
            self.writePrint(0, '"[%s] -garbage collector -"' % prefix)
            self.write(0, "collect()   # explicit call to the garbage collector")
            self.restoreLevel(level)
        self.emptyLine()

    def writeCode(
        self,
        prefix,
        object,
        functions,
        classes,
        objects,
        func_min_arg,
        nb_call,
        obj_name=None,
    ):
        if functions:
            for index in xrange(nb_call):
                func_name = choice(functions)
                func = getattr(object, func_name)
                self.callFunction(
                    prefix, index, func_name, func, func_min_arg, obj_name
                )
        if classes:
            self.nb_class = self.options.classes_number
            for index in xrange(self.nb_class):
                class_name = choice(classes)
                cls = getattr(object, class_name)
                self.useClass(index, cls, class_name)
        if objects:
            for index in xrange(self.options.objects_number):
                object_name = choice(objects)
                obj = getattr(object, object_name)
                if object_name in OBJECT_BLACKLIST or isinstance(obj, ModuleType):
                    continue
                self.useObject(index, obj, object_name)

    def genNone(self):
        return ["None"]

    def genTricky(self):
        return [
            choice(
                [
                    "liar1",
                    "liar2",
                    # "lst",
                    "lambda *args, **kwargs: 1/0",
                    "int",
                    "type",
                    "object()",
                    "[[[[[[[[[[[[[[]]]]]]]]]]]]]]",
                    "MagicMock()",
                    "Evil()",
                    "MagicMock",
                    "Evil",
                    "Liar1",
                    "Liar2",
                ]
            )
        ]

    def genBool(self):
        if randint(0, 1) == 1:
            return ["True"]
        else:
            return ["False"]

    def genSmallUint(self):
        return [self.smallint_generator.createValue()]

    def genInt(self):
        return [self.int_generator.createValue()]

    def genBytes(self):
        # Bytes string
        bytes = self.bytes_generator.createValue()
        if RUNNING_PYTHON3:
            text = "".join("\\x%02X" % byte for byte in bytes)
            text = 'b"%s"' % text
        else:
            text = "".join("\\x%02X" % ord(byte) for byte in bytes)
            text = '"%s"' % text
        return [text]

    def genUnixPath(self):
        path = self.unix_path_generator.createValue()
        return ['"%s"' % path]

    def _genUnicode(self, generator):
        # (Unicode) character string
        text = generator.createValue()
        text = escapeUnicode(text)
        if RUNNING_PYTHON3:
            text = '"%s"' % text
        else:
            text = 'u"%s"' % text
        return [text]

    def genLetterDigit(self):
        return self._genUnicode(self.letters_generator)

    def genString(self):
        return self._genUnicode(self.unicode_generator)

    def genRawString(self):
        sequences = (
            [r"\d", r"\D", r"\w", r"\W", r"\s", r"\S", r"\b", r"\B", r"\A", r"\Z"]
            + sorted(LETTERS)
            + ["."] * 10
        )
        special = ["+", "?", "*"]
        result = []
        for x in range(randint(3, 20)):
            result.append("".join(sample(sequences, randint(1, 3))))
            if randint(0, 9) > 8:
                result.append(choice(special))
        return [f'r"{"".join(result)}"']

    def genSurrogates(self):
        text = choice(SURROGATES)
        return [text]

    def genInterestingValues(self):
        interesting = choice(INTERESTING)
        return [interesting]

    def genTrickyObjects(self):
        tricky = choice(fusil.python.tricky_weird.tricky_objects_names)
        return [tricky]

    def genTrickyNumpy(self):
        tricky = choice(fusil.python.tricky_weird.tricky_numpy_names)
        return [tricky]

    def genTrickyTemplate(self):
        tricky = choice(TEMPLATES)
        return [tricky]

    def genWeirdClass(self):
        weird_class_name = choice(fusil.python.tricky_weird.weird_names)
        return [f"weird_classes['{weird_class_name}']"]

    def genWeirdInstance(self):
        weird_class_name = choice(fusil.python.tricky_weird.weird_instance_names)
        return [f"weird_instances['{weird_class_name}']"]

    def genWeirdType(self):
        weird_class_name = choice(fusil.python.tricky_weird.weird_names)
        type_name = choice(fusil.python.tricky_weird.type_names)
        return [f"{type_name}[weird_classes['{weird_class_name}']]"]

    def genWeirdUnion(self):
        weird_class_name1 = choice(fusil.python.tricky_weird.weird_names)
        weird_class_name2 = choice(fusil.python.tricky_weird.weird_names)
        type_name = choice(fusil.python.tricky_weird.type_names)
        return [f"{type_name}[weird_classes['{weird_class_name1}']] | weird_classes['{weird_class_name2}'] | big_union"]

    def genBufferObject(self):
        text = choice(BUFFER_OBJECTS)
        return [text]

    def genAsciiString(self):
        return self._genUnicode(self.ascii_generator)

    def genFloat(self):
        int_part = self.float_int_generator.createValue()
        float_part = self.float_float_generator.createValue()
        return ["%s.%s" % (int_part, float_part)]

    def genExistingFilename(self):
        filename = choice(self.filenames)
        return ["'%s'" % filename]

    def genErrback(self):
        return ["%s" % ERRBACK_NAME]

    def genOpenFile(self):
        filename = choice(self.filenames)
        if RUNNING_PYTHON3:
            instr = "open('%s')" % filename
        else:
            instr = "open(u'%s')" % filename
        return [instr]

    def genException(self):
        return ["Exception('pouet')"]

    def _genList(self, open_text, close_text, empty, is_dict=False):
        # 90% of the time generate values of the same type
        same_type = randint(0, 9) != 0
        nb_item = randint(0, 9)
        if not nb_item:
            return [empty]
        items = []
        if same_type:
            if is_dict:
                key_callback = choice(self.hashable_argument_generators)
            value_callback = choice(self.simple_argument_generators)
            for index in xrange(nb_item):
                if is_dict:
                    item = self.createDictItem(key_callback, value_callback)
                else:
                    item = value_callback()
                items.append(item)
        else:
            for index in xrange(nb_item):
                if is_dict:
                    item = self.createDictItem()
                else:
                    item = self.createArgument()
                items.append(item)
        lines = []
        for item_index, item_lines in enumerate(items):
            if item_index:
                lines[-1] += ","
                for index, line in enumerate(item_lines):
                    # Add ' ' suffix to all lines
                    item_lines[index] = " " + line
            lines.extend(item_lines)
        if nb_item == 1 and empty == "tuple()":
            lines[-1] += ","
        lines[0] = open_text + lines[0]
        lines[-1] += close_text
        return lines

    def createDictItem(self, key_callback=None, value_callback=None):
        if key_callback:
            key = key_callback()
        else:
            key = self.createHashableArgument()
        if value_callback:
            value = value_callback()
        else:
            value = self.createArgument()
        key[-1] += ": " + value[0]
        key.extend(value[1:])
        return key

    def genList(self):
        return self._genList("[", "]", "[]")

    def genTuple(self):
        return self._genList("(", ")", "tuple()")

    def genDict(self):
        return self._genList("{", "}", "{}", True)


def remove_logging_pycache():
    """Remove stale logging __pycache__ that causes logging errors."""
    import importlib
    import logging
    import pathlib

    pycache = pathlib.Path(logging.__file__).parent / "__pycache__"
    for entry in pycache.iterdir():
        try:
            entry.unlink()
        except Exception:
            pass
    try:
        pycache.rmdir()
    except Exception:
        pass
    importlib.reload(logging)


def print_running_time():
    raw_utime = resource.getrusage(resource.RUSAGE_SELF).ru_utime
    user_time = str(datetime.timedelta(0, round(raw_utime, 2)))
    total_time = str(datetime.timedelta(0, round(time.time() - time_start, 2)))
    return f"\nRunning time: {total_time[:-4]}\nUser time:    {user_time[:-4]}"


if __name__ == "__main__":
    time_start = time.time()
    import_all()
    remove_logging_pycache()
    Fuzzer().main()
