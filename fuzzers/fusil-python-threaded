#!/usr/bin/env python
"""
Fusil Python Fuzzer

A Python fuzzer based on the fusil fuzzing framework for testing Python modules
by generating random function and method calls with diverse argument types.
This fuzzer targets Python modules to discover crashes and other issues through
exploration of API surfaces.

Key Features:
- Discovery and filtering of Python modules (stdlib, site-packages, C-only)
- Generation of complex arguments, including edge cases and malformed data
- Thread-based and async execution, mostly targeting free-threaded builds
- Support for numpy arrays and template strings (PEP 750) when available
- Blacklisting system to filter out dangerous or irrelevant functions and modules
- Resource monitoring and timeout handling
- Configurable fuzzing parameters (function calls, methods, classes, objects)

The fuzzer generates Python source code that imports target modules and executes
randomized function calls, capturing crashes and unexpected behaviors for analysis.
It's particularly effective at finding issues in C extension modules where memory
safety bugs are more common. Stressing and exercising the core interpreter can
also find crashes.

Usage:
    python fusil-python-threaded [options]

Example:
    python fusil-python-threaded --only-c --timeout 300 --modules json,sqlite3
"""

from __future__ import annotations

import builtins
import datetime
import inspect
import pathlib
import pkgutil
import random
import resource
import sys
import time
import warnings
from os.path import exists as path_exists
from os.path import isabs
from random import choice, randint
from textwrap import dedent
from types import BuiltinFunctionType, FunctionType, ModuleType
from typing import Any, Callable, Generator

# Hide Python warnings on import
warnings.simplefilter("ignore")

import fusil.python.tricky_weird
from fusil.application import Application
from fusil.config import (
    ConfigParserWithHelp,
    FusilConfig,
    OptionGroupWithSections,
    createFilename,
)
from fusil.process.create import CreateProcess
from fusil.process.stdout import WatchStdout
from fusil.process.watch import WatchProcess
from fusil.project import Project
from fusil.project_agent import ProjectAgent
from fusil.python.arg_numbers import class_arg_number, get_arg_number
from fusil.python.argument_generator import ArgumentGenerator
from fusil.python.blacklists import (
    BLACKLIST,
    METHOD_BLACKLIST,
    MODULE_BLACKLIST,
    OBJECT_BLACKLIST,
)
from fusil.python.mangle import mangle_loop, mangle_obj
from fusil.write_code import WriteCode


ERRBACK_NAME_CONST = "errback"
CALL_REPETITION_COUNT_CONST = 65
USE_MANGLE_FEATURE = False

try:
    from fusil.python.template_strings import TEMPLATES

    print("Template strings available.")
    _ARG_GEN_USE_TEMPLATES = True
except ImportError:
    print("Template strings not available.")
    _ARG_GEN_USE_TEMPLATES = False

try:
    import numpy  # type: ignore

    print(f"Numpy {numpy.__version__} is available, using it to build tricky arrays.")
    _ARG_GEN_USE_NUMPY = True
except ImportError:
    print("Numpy is not available.")
    _ARG_GEN_USE_NUMPY = False

print(sys.version)

# Fuzzer options
IGNORE_TIMEOUT = True
IGNORE_CPU = True
SHOW_STDOUT = False
DEBUG = False
USE_MANGLE = False
TIMEOUT = 900.0

# Constants
PYTHON = sys.executable
FILENAMES = "/etc/machine-id,/bin/sh"
DEFAULT_NB_CALL = 250
DEFAULT_NB_METHOD = 15
DEFAULT_NB_CLASS = 50
DEFAULT_NB_OBJ = 100
ERRBACK_NAME = "errback"

EXCEPTION_NAMES = {
    cls.__name__
    for cls in builtins.__dict__.values()
    if isinstance(cls, type) and issubclass(cls, Exception)
}


def import_all() -> None:
    """Import all standard library C modules before running the fuzzer."""
    # Currently we have to import all C modules before running the fuzzer.
    # TODO: figure out why and fix it properly.
    for name in sys.stdlib_module_names:
        if name not in MODULE_BLACKLIST and "test" not in name:
            try:
                sys.modules[name] = __import__(name)
            except ImportError as e:
                print("Failed to import module %s\n" % name, e)


class PythonFuzzerError(Exception):
    """Custom exception raised when fuzzer encounters unrecoverable errors."""


class ListAllModules:
    """
    Discovers and filters Python modules suitable for fuzzing.

    This class provides functionality to scan the available Python modules,
    applying various filters to identify modules that are appropriate for
    fuzzing operations. It can filter based on module type (C vs Python),
    location (site-packages vs stdlib), and custom blacklists.

    Args:
        logger: Logger instance for outputting messages
        only_c: If True, only include C extension modules
        site_package: If True, include modules from site-packages
        blacklist: set of module names/patterns to exclude
        skip_test: If True, skip test modules (currently unused)
        verbose: If True, output detailed logging information
    """

    def __init__(
        self,
        logger: PythonSource,
        only_c: bool,
        site_package: bool,
        blacklist: set[str],
        skip_test: bool,
        verbose: bool = False,
    ):
        self.logger = logger
        self.only_c = only_c
        self.site_package = site_package
        self.blacklist = blacklist
        self.skip_test = skip_test
        self.verbose = verbose

        self.discovered_modules: set[str] = set(sys.builtin_module_names) - {"__main__"}
        self._seen_paths: set[str] = set()

    def _is_valid_module(
        self,
        name: str,
        is_package: bool,
        filename: str | None,
        path: list[str] | None,
        package: str | None,
        prefix: str = "",
    ) -> bool:
        """
        Check if a module meets the filtering criteria for fuzzing.

        Args:
            name: Module name
            is_package: True if the module is a package
            filename: Module filename (if available)
            path: Module path list (if available)
            package: Parent package name (if available)
            prefix: Module name prefix (for submodules)

        Returns:
            True if the module should be included, False otherwise
        """
        filename = filename or ""
        path = path or []
        package = package or ""

        if not self.site_package:
            if "site-packages" in filename or any("site-packages" in p for p in path):
                return False

        if self.only_c:
            if any(filename.endswith(ext) for ext in (".py", ".pyc", ".pyo")):
                return False
            if is_package or not self._is_c_module(name, prefix):
                return False

        search_targets = [name, package, pathlib.Path(filename).name, prefix]
        if any(
            blacklist_entry in target
            for blacklist_entry in self.blacklist
            for target in search_targets
        ):
            return False

        return True

    def _is_c_module(self, name: str, prefix: str) -> bool:
        """
        Determine if a module is implemented in C.

        Args:
            name: Module name
            prefix: Module prefix

        Returns:
            True if the module is a (probable) C extension, False if it's Python
        """
        fullname = prefix + name

        if self.verbose:
            print(f"Testing if {fullname} is C module...")

        module = self._find_module(fullname, name, prefix)

        if not module:
            if self.verbose:
                print(f"    Could not import {fullname}, assuming C module")
            return True

        if not hasattr(module, "__file__") or module.__file__ is None:
            if self.verbose:
                print(f"    {fullname} has no __file__, likely builtin C module")
            return True

        module_file = str(module.__file__)
        is_python = module_file.endswith((".py", ".pyc", ".pyo", ".pyw"))

        if self.verbose:
            file_type = "Python" if is_python else "C"
            print(f"    {fullname} is {file_type} module (file: {module_file})")

        if is_python and self.verbose:
            self.logger.error(f"SKIP PYTHON MODULE {fullname}")

        return not is_python

    def _find_module(self, fullname: str, name: str, prefix: str) -> ModuleType | None:
        """
        Attempt to find and import a module using various strategies.

        Args:
            fullname: Full module name with prefix
            name: Base module name
            prefix: Module prefix

        Returns:
            The imported module or None if not found
        """
        # Try different module name variations
        candidates = [
            fullname,
            name,
            name.split(".")[0],
            prefix.rstrip("."),
            prefix.split(".")[0] if prefix else None,
        ]

        for candidate in candidates:
            if candidate and candidate in sys.modules:
                return sys.modules[candidate]

        try:
            return __import__(fullname)
        except ImportError as e:
            if self.verbose:
                print(f"    Import failed for {fullname}: {e}")
            return None

    def _discover_modules(
        self,
        path: list[str] | None = None,
        prefix: str = "",
        onerror: Callable[[str], None] | None = None,
    ) -> Generator[pkgutil.ModuleInfo, None, None]:
        """
        Recursively discover modules, yielding valid ones.

        Args:
            path: list of paths to search (None for default)
            prefix: Current module prefix
            onerror: Callback for handling import errors

        Yields:
            ModuleInfo objects for valid modules
        """
        for info in pkgutil.iter_modules(path, prefix):
            if info.name in self.blacklist:
                continue

            # Skip Debian debug modules (e.g., "_bisect_d")
            if info.name.endswith("_d"):
                continue

            module_data = self._get_module_metadata(info.name)

            if not self._is_valid_module(
                info.name,
                info.ispkg,
                module_data.get("filename"),
                module_data.get("path"),
                module_data.get("package"),
                prefix,
            ):
                if self.verbose:
                    print(f"SKIPPED {prefix + info.name}", file=sys.stderr)
                continue

            yield info

            if info.ispkg:
                yield from self._process_package(info, onerror)

    def _get_module_metadata(self, module_name: str) -> dict[str, Any]:
        """Get metadata for a module if it's already imported."""
        if module_name not in sys.modules:
            return {}

        module = sys.modules[module_name]
        return {
            "path": getattr(module, "__path__", None),
            "package": getattr(module, "__package__", None),
            "filename": getattr(module, "__file__", None),
        }

    def _process_package(
        self, info: pkgutil.ModuleInfo, onerror: Callable[[str], None] | None
    ) -> Generator[pkgutil.ModuleInfo, None, None]:
        """
        Process a package by importing it and recursively scanning submodules.

        Args:
            info: Package information
            onerror: Error handling callback

        Yields:
            ModuleInfo objects for submodules
        """
        try:
            __import__(info.name)
        except (ImportError, Exception) as e:
            if onerror:
                onerror(info.name)
            elif not isinstance(e, ImportError):
                raise
            return

        if info.name not in sys.modules:
            return

        module_path = getattr(sys.modules[info.name], "__path__", None)
        if not module_path:
            return

        # Filter out already seen paths
        new_paths = [p for p in module_path if p not in self._seen_paths]
        self._seen_paths.update(new_paths)

        if new_paths:
            yield from self._discover_modules(new_paths, info.name + ".", onerror)

    def search_modules(self, prefix: str = "") -> set[str]:
        """
        Search for and return all valid modules for fuzzing.

        Args:
            prefix: Optional prefix to add to module names

        Returns:
            set of module names that passed all filters
        """
        for info in self._discover_modules(onerror=lambda x: None):
            fullname = prefix + info.name
            if self.verbose:
                self.logger.error(f"ADDING {fullname}: {prefix}+{info.name}")
            self.discovered_modules.add(fullname)

        return self.discovered_modules


class Fuzzer(Application):
    """Main fuzzer application that coordinates the fuzzing process."""

    NAME = "python"

    def createFuzzerOptions(self, parser: ConfigParserWithHelp) -> None:
        """Create command-line options for the fuzzer configuration."""
        input_options = OptionGroupWithSections(parser, "Input")
        input_options.add_option(
            "--modules",
            help="Tested Python module names separated by commas (default: test all modules)",
            type="str",
            default="*",
        )
        input_options.add_option(
            "--packages",
            help="Tested Python packages names separated by commas (default: test all packages)",
            type="str",
            default="*",
        )
        input_options.add_option(
            "--skip-test",
            help="Skip modules with 'test' in the name (default: False)",
            action="store_true",
            default=False,
        )
        input_options.add_option(
            "--blacklist",
            help='Module blacklist separated by commas (eg. "_lsprof,_json")',
            type="str",
            default="",
        )
        input_options.add_option(
            "--test-private",
            help="Test private methods (default: skip privates methods)",
            action="store_true",
            default=False,
        )
        input_options.add_option(
            "--only-c",
            help="Only search for modules written in C (default: search all module)",
            action="store_true",
            default=False,
        )
        input_options.add_option(
            "--no-site-packages",
            help="Don't search modules in site-packages directory",
            action="store_true",
            default=False,
        )
        running_options = OptionGroupWithSections(parser, "Running")
        running_options.add_option(
            "--timeout",
            help="Timeout in seconds (default: %d)" % TIMEOUT,
            type="float",
            default=TIMEOUT,
        )
        running_options.add_option(
            "--python",
            help="Python executable program path (default: %s)" % PYTHON,
            type="str",
            default=PYTHON,
        )
        running_options.add_option(
            "--record-timeouts",
            help="Consider timeouts as errors (default: False)",
            action="store_true",
            default=False,
        )
        running_options.add_option(
            "--record-high-cpu",
            help="Consider high CPU usage an error (default: False)",
            action="store_true",
            default=False,
        )
        running_options.add_option(
            "--show-stdout",
            help="Display STDOUT (default: False)",
            action="store_true",
            default=False,
        )
        fuzzing_options = OptionGroupWithSections(parser, "Fuzzing")
        fuzzing_options.add_option(
            "--functions-number",
            help="Number of function calls to generate per module (default: %d)"
            % DEFAULT_NB_CALL,
            type="int",
            default=DEFAULT_NB_CALL,
        )
        fuzzing_options.add_option(
            "--methods-number",
            help="Number of method calls to create for each class or object (default: %d)"
            % DEFAULT_NB_METHOD,
            type="int",
            default=DEFAULT_NB_METHOD,
        )
        fuzzing_options.add_option(
            "--classes-number",
            help="Number of classes to fuzz per module (default: %d)"
            % DEFAULT_NB_CLASS,
            type="int",
            default=DEFAULT_NB_CLASS,
        )
        fuzzing_options.add_option(
            "--objects-number",
            help="Number of objects to fuzz per module (default: %d)" % DEFAULT_NB_OBJ,
            type="int",
            default=DEFAULT_NB_OBJ,
        )
        # options.add_option(
        #     "--no-mangle",
        #     help="Don't mangle objects (default: False)",
        #     action="store_true",
        # )
        fuzzing_options.add_option(
            "--fuzz-exceptions",
            help="Include basic Exceptions in fuzzing (default: False)",
            action="store_true",
            default=False,
        )
        fuzzing_options.add_option(
            "--no-async",
            help="Don't run code asynchronously (default: False)",
            action="store_true",
            default=False,
        )
        fuzzing_options.add_option(
            "--no-threads",
            help="Don't run code in threads (default: False)",
            action="store_true",
            default=False,
        )
        fuzzing_options.add_option(
            "--no-numpy",
            help="Don't use Numpy (default: False)",
            action="store_true",
            default=False,
        )
        fuzzing_options.add_option(
            "--no-tstrings",
            help="Don't use template strings (default: False)",
            action="store_true",
            default=False,
        )
        fuzzing_options.add_option(
            "--filenames",
            help="Names separated by commas of readable files (default: %s)"
            % FILENAMES,
            type="str",
            default=FILENAMES,
        )
        config_options = OptionGroupWithSections(parser, "Configuration")
        config_options.add_option(
            "--write-config",
            help="Write a sample configuration file if one doesn't exist (default: False)",
            action="store_true",
            default=False,
        )
        config_options.add_option(
            "--config-file",
            help="Name of the configuration file to be read or written (default: %s)"
            % createFilename(),
            type="str",
            default=createFilename(),
        )
        config_options.add_option(
            "--use-config",
            help="Load settings from configuration file (default: False)",
            action="store_true",
            default=False,
        )

        options = input_options, running_options, fuzzing_options, config_options
        for option in options:
            parser.add_option_group(option)

    def setupProject(self) -> None:
        """Initialize the fuzzing project with process monitoring and output analysis."""
        project = self.project
        assert isinstance(project, Project)

        project.error(f"Start time: {time.asctime()}")
        project.error("Use python interpreter: %s" % self.options.python)
        version = " -- ".join(line.strip() for line in sys.version.splitlines())
        project.error("Python version: %s" % version)
        PythonSource(project, self.options)
        process = PythonProcess(
            project,
            [self.options.python, "-u", "<source.py>"],
            timeout=self.options.timeout,
        )
        process.max_memory = 4000 * 1024 * 1024 * 1024 * 1024
        options = {"exitcode_score": 0}
        if not self.options.record_timeouts:
            options["timeout_score"] = 0
        watch = WatchProcess(process, **options)
        if watch.cpu and not self.options.record_high_cpu:
            watch.cpu.max_score = 0

        stdout = WatchStdout(process)
        stdout.max_nb_line = None

        # Disable dummy error messages
        stdout.words = {
            "oops": 0.30,
            "bug": 0.10,
            "fatal": 0.1,
            # "assert": 0.025,
            "assertion": 1.0,
            "critical": 1.0,
            "panic": 1.0,
            "panicked": 1.0,  # For Rust errors
            "glibc detected": 1.0,
            "segfault": 1.0,
            "segmentation fault": 1.0,
            "SystemError": 1.0,
            "AddressSanitizer": 1.0,
        }

        stdout.kill_words = {"MemoryError", "mimalloc"}

        # CPython critical messages
        stdout.addRegex("^XXX undetected error", 1.0)
        stdout.addRegex("Fatal Python error", 1.0)
        # Match "Cannot allocate memory"?

        # PyPy messages
        stdout.addRegex("Fatal RPython error", 1.0)

        if self.options.show_stdout or self.options.debug:
            stdout.show_matching = True
            stdout.show_not_matching = True

        # avoid matching on "assert" keyword
        stdout.ignoreRegex(r"ast\.Assert()")

        # PyPy interact prompt
        # avoid false positive on "# assert did not crash"
        stdout.ignoreRegex(r"^And now for something completely different:")

        # import_all()

    def exit(self, keep_log: bool = True) -> None:
        """Clean up and exit the fuzzer, printing runtime statistics."""
        super().exit(keep_log=keep_log)
        self.error(print_running_time())


class PythonSource(ProjectAgent):
    """Manages module discovery, loading, and Python source code generation."""

    def __init__(self, project: Project, options: FusilConfig):
        ProjectAgent.__init__(self, project, "python_source")
        self.options = options
        if self.options.modules != "*":
            self.modules = set()
            for module in self.options.modules.split(","):
                module = module.strip()
                if not len(module):
                    continue
                self.modules.add(module)
        else:
            self.error("Search all Python modules...")
            self.modules = ListAllModules(
                self,
                self.options.only_c,
                not self.options.no_site_packages,
                MODULE_BLACKLIST
                | set(name for name in self.options.blacklist.split(",") if name),
                self.options.skip_test,
                verbose=self.options.verbose,
            ).search_modules()
        if self.options.packages != "*":
            print("\nAdding packages...")
            all_modules = ListAllModules(
                self,
                self.options.only_c,
                not self.options.no_site_packages,
                MODULE_BLACKLIST
                | set(name for name in self.options.blacklist.split(",") if name),
                self.options.skip_test,
                verbose=self.options.verbose,
            )
            for package in self.options.packages.split(","):
                package = package.strip().strip("/")
                if not len(package):
                    continue
                pack = __import__(package)
                path = pack.__path__[0]
                print(f"Adding package: {package} ({path})")
                package_walker = all_modules.walk_packages([path], package + ".")
                self.modules |= set(mod.name for mod in package_walker)

            if self.options.verbose:
                print(
                    f"\nKnown modules ({len(self.modules)}): {','.join(sorted(self.modules))}"
                )

        blacklist = self.options.blacklist
        if blacklist:
            blacklist = set(blacklist.split(","))
            removed = self.modules & blacklist
            self.error("Blacklist modules: %s" % removed)
            self.modules = self.modules - blacklist
        self.modules_list = list(self.modules)
        self.modules_list.sort()
        self.error("Found %s Python modules" % len(self.modules_list))
        for name in self.modules_list:
            self.info("Python module: %s" % name)

        self.filenames = self.options.filenames
        self.filenames = self.filenames.split(",")
        for filename in self.filenames:
            if not isabs(filename):
                raise ValueError(
                    "Filename %r is not an absolute path! Fix the --filenames option"
                    % filename
                )
            if not path_exists(filename):
                raise ValueError(
                    "File doesn't exist: %s! Use different --filenames option"
                    % filename
                )
        project.error("Use filenames: %s" % ", ".join(self.filenames))
        self.error(print_running_time())

    def loadModule(self, module_name: str) -> None:
        """Load a specific module and prepare it for fuzzing."""
        self.module_name = module_name
        self.debug("Import %s" % self.module_name)
        self.module = __import__(self.module_name)
        for name in self.module_name.split(".")[1:]:
            self.module = getattr(self.module, name)
        try:
            self.warning("Module filename: %s" % self.module.__file__)
        except AttributeError:
            pass
        self.write = WritePythonCode(
            self,
            self.filename,
            self.module,
            self.module_name,
            threads=not self.options.no_threads,
            _async=not self.options.no_async,
        )

    def on_session_start(self) -> None:
        """Start a new fuzzing session by selecting a module and generating test code."""
        self.filename = self.session().createFilename("source.py")

        # copy sys.modules
        old_sys_modules = sys.modules.copy()

        name = "NO_MODULES!"
        while self.modules_list:
            name = choice(self.modules_list)
            try:
                self.loadModule(name)
                break
            except BaseException as err:
                self.error(
                    "Unable to load module %s: [%s] %s"
                    % (name, err.__class__.__name__, err)
                )
                self.modules_list.remove(name)
        if not self.modules_list:
            self.error("There are no more modules!")
            self.send("project_stop")
            return
        self.error("Test module %s" % name)
        self.error(print_running_time())
        self.send("session_rename", name)

        self.write.generate_fuzzing_script()
        self.send("python_source", self.filename)

        # unload new modules
        sys.modules.clear()
        sys.modules.update(old_sys_modules)


class PythonProcess(CreateProcess):
    """Handles the execution of generated Python test code."""

    def on_python_source(self, filename: str) -> None:
        """Execute the generated Python source file."""
        self.cmdline.arguments[-1] = filename
        self.createProcess()


class WritePythonCode(WriteCode):
    """Generates Python source code with randomized function calls for fuzzing."""

    def __init__(
        self,
        parent_python_source: PythonSource,
        filename: str,
        module: ModuleType,
        module_name: str,
        threads: bool = True,
        _async: bool = True,
    ):
        """Initialize the Python code writer."""
        super().__init__()  # Initialize base WriteCode
        self.parent_python_source = parent_python_source
        self.options = parent_python_source.options
        self.filenames = parent_python_source.filenames
        self.module = module
        self.module_name = module_name
        self.enable_threads = threads
        self.enable_async = _async
        self.generated_filename = filename

        self.arg_generator = ArgumentGenerator(
            self.options, self.filenames, _ARG_GEN_USE_NUMPY, _ARG_GEN_USE_TEMPLATES
        )

        self.module_functions: list[str]
        self.module_classes: list[str]
        self.module_objects: list[str]
        self.module_functions, self.module_classes, self.module_objects = (
            self._get_module_members()
        )

        if (
            not self.module_functions
            and not self.module_classes
            and not self.module_objects
        ):
            raise PythonFuzzerError(
                f"Module {self.module_name} has no function, no class, and no object to fuzz!"
            )

    def write_print_to_stderr(self, level: int, arguments_str: str) -> None:
        """Write a print statement to stderr at the specified indentation level."""
        code = f"print({arguments_str}, file=stderr)"
        self.write(level, code)

    def _get_module_members(self) -> tuple[list[str], list[str], list[str]]:
        """Extracts fuzzable functions, classes, and objects from the current module."""
        _EXCEPTION_NAMES = EXCEPTION_NAMES

        classes = []
        functions = []
        objects = []
        try:
            module_blacklist = BLACKLIST.get(self.module_name, set())
        except KeyError:
            module_blacklist = set()

        current_blacklist = module_blacklist | METHOD_BLACKLIST

        names = set(dir(self.module))
        names -= {
            "__builtins__",
            "__doc__",
            "__file__",
            "__name__",
            "__package__",
            "__loader__",
            "__spec__",
        }
        names -= {"True", "None", "False"}

        if not self.options.fuzz_exceptions:
            names -= _EXCEPTION_NAMES

        names -= current_blacklist

        for name in sorted(list(names)):
            if name.startswith("_") and not self.options.test_private:
                if not (name.startswith("__") and name.endswith("__")):
                    continue

            try:
                attr = getattr(self.module, name)
            except AttributeError:
                # Attribute listed in dir() but not actually gettable (e.g., from __all__ but not defined)
                continue
            except Exception:
                self.parent_python_source.warning(
                    f"Could not getattr {name} from {self.module_name}"
                )
                continue

            if isinstance(attr, (FunctionType, BuiltinFunctionType)):
                functions.append(name)
            elif isinstance(attr, type) or inspect.isclass(attr):
                if (
                    not self.options.fuzz_exceptions
                    and isinstance(attr, type)
                    and issubclass(attr, BaseException)
                    and attr.__name__ in _EXCEPTION_NAMES
                ):
                    continue
                classes.append(name)
            else:
                if isinstance(attr, ModuleType):
                    continue
                if (
                    not self.options.fuzz_exceptions
                    and isinstance(attr, BaseException)
                    and attr.__class__.__name__ in _EXCEPTION_NAMES
                ):
                    continue
                objects.append(name)
        return functions, classes, objects

    def _get_object_methods(
        self, obj_instance_or_class: Any, owner_name: str
    ) -> dict[str, Callable[..., Any]]:
        """Extracts callable methods from an object or class, respecting blacklists."""
        methods: dict[str, Callable[..., Any]] = {}
        if type(obj_instance_or_class) in {
            int,
            str,
            float,
            bool,
            bytes,
            tuple,
            list,
            dict,
            set,
            type(None),
        }:
            return methods

        try:
            key = f"{self.module_name}:{owner_name}"
            blacklist = BLACKLIST.get(key, set())
        except KeyError:
            blacklist = set()
        blacklist |= METHOD_BLACKLIST

        is_exception_type_or_instance = (
            isinstance(obj_instance_or_class, type)
            and issubclass(obj_instance_or_class, BaseException)
        ) or isinstance(obj_instance_or_class, BaseException)

        for name in dir(obj_instance_or_class):
            if name in blacklist:
                continue
            if (
                (not self.options.test_private)
                and name.startswith("__")
                and not name.endswith("__")
            ):
                if name not in {
                    "__init__",
                    "__call__",
                    "__getitem__",
                    "__setitem__",
                    "__iter__",
                    "__next__",
                    "__len__",
                    "__contains__",
                    "__eq__",
                    "__lt__",
                    "__gt__",
                    "__le__",
                    "__ge__",
                    "__repr__",
                    "__str__",
                }:
                    continue

            if (
                is_exception_type_or_instance and name == "__init__"
            ):  # Avoid re-initing exceptions
                continue

            try:
                attr = getattr(obj_instance_or_class, name, None)
                if attr is None or not callable(attr):
                    continue
            except Exception:  # getattr itself might fail
                continue
            methods[name] = attr
        return methods

    def _write_script_header_and_imports(self) -> None:
        """Writes standard imports and initial setup code to the generated script."""
        self.write(
            0,
            dedent(
                """\
                from gc import collect
                from sys import stderr, path as sys_path
                from os.path import dirname
                import inspect
                import time
                import sys
                from threading import Thread
                from unittest.mock import MagicMock
                import asyncio
                """
            ),
        )
        if not self.options.no_tstrings and _ARG_GEN_USE_TEMPLATES:
            self.write(0, "from string.templatelib import Interpolation, Template")

        self.write_print_to_stderr(0, f'"Importing target module: {self.module_name}"')
        self.write(0, f"import {self.module_name}")
        self.emptyLine()

    def _write_tricky_definitions(self) -> None:
        """Writes definitions for 'tricky' classes and objects."""
        self.write(0, fusil.python.tricky_weird.weird_classes)
        self.emptyLine()
        self.write(0, fusil.python.tricky_weird.tricky_typing)
        self.emptyLine()
        self.write(0, fusil.python.tricky_weird.tricky_objects)
        self.emptyLine()
        if not self.options.no_numpy and _ARG_GEN_USE_NUMPY:
            self.write(0, "import numpy")
            self.write(0, fusil.python.tricky_weird.tricky_numpy)
            self.emptyLine()

        self.write(
            0,
            dedent(
                f"""\
                def {ERRBACK_NAME_CONST}(*args, **kw):
                    raise ValueError('errback called')
                """
            ),
        )
        self.emptyLine()

        self.write(
            0,
            dedent(
                f"""\
                class Liar1:
                    def __eq__(self, other):
                        return True
                
                class Liar2:
                    def __eq__(self, other):
                        return False
                
                liar1, liar2 = Liar1(), Liar2()
                
                class Evil:
                    def __eq__(self, other):
                        for attr in dir(other):
                            try: other.__dict__[attr] = {ERRBACK_NAME_CONST}
                            except: pass
                
                evil = Evil()
                
                """
            ),
        )

        if USE_MANGLE_FEATURE:
            self.write(0, mangle_obj)
        self.emptyLine()

    def _write_helper_call_functions(self) -> None:
        """Writes the callMethod and callFunc helper functions into the script."""
        self.write(0, "def callMethod(prefix, obj_to_call, method_name, *arguments):")
        current_level = self.addLevel(1)
        self.write(
            0,
            f'func_display_name = f"{self.module_name}.{{method_name}}()" if obj_to_call is {self.module_name} else f"{{obj_to_call.__class__.__name__}}.{{method_name}}()"',
        )
        self.write(0, 'message = f"[{prefix}] {func_display_name}"')
        self.write(0, "SENTINEL_VALUE = object()")
        self.write_print_to_stderr(0, "message")
        self.write(0, "result = SENTINEL_VALUE")
        self.write(0, "try:")
        self.addLevel(1)
        self.write(0, "func_to_run = getattr(obj_to_call, method_name)")
        self.write(0, f"for _ in range({CALL_REPETITION_COUNT_CONST}):")
        self.write(1, "result = func_to_run(*arguments)")
        self.restoreLevel(current_level + 1)
        self.write(0, "except (Exception, SystemExit, KeyboardInterrupt) as err:")
        self.addLevel(1)
        self.write(0, "try:")
        self.write(1, "errmsg = repr(err)")
        self.write(0, "except Exception as e_repr:")
        self.write(1, "errmsg = f'Error during repr: {e_repr.__class__.__name__}'")
        self.write(0, "errmsg = errmsg.encode('ASCII', 'replace').decode('ASCII')")
        self.write_print_to_stderr(
            0,
            'f"[{prefix}] {func_display_name} => EXCEPTION: {err.__class__.__name__}: {errmsg}"',
        )
        self.write(0, "result = SENTINEL_VALUE")
        self.restoreLevel(current_level + 1)

        self.write_print_to_stderr(0, 'f"[{prefix}] -explicit garbage collection-"')
        self.write(0, "collect()")

        if self.enable_threads:
            self.write(0, "if result is not SENTINEL_VALUE:")
            self.write(
                1,
                "fuzzer_threads_alive.append(Thread(target=func_to_run, args=arguments, name=message))",
            )
        self.write(0, "return result")
        self.restoreLevel(current_level)
        self.emptyLine()

        self.write(0, "def callFunc(prefix, func_name_str, *arguments):")
        self.write(
            1,
            f"return callMethod(prefix, {self.module_name}, func_name_str, *arguments)",
        )
        self.emptyLine()

    def _write_main_fuzzing_logic(self) -> None:
        """Writes the core fuzzing loops for functions, classes, and objects."""
        self.write(0, f"fuzz_target_module = {self.module_name}")
        self.emptyLine()

        if self.enable_threads:
            self.write(0, "fuzzer_threads_alive = []")
        if self.enable_async:
            self.write(0, "fuzzer_async_tasks = []")
        self.emptyLine()

        if self.module_functions:
            self.write_print_to_stderr(
                0,
                f'"--- Fuzzing {len(self.module_functions)} functions in {self.module_name} ---"',
            )
            for i in range(self.options.functions_number):
                func_name = choice(self.module_functions)
                try:
                    func_obj = getattr(self.module, func_name)
                except AttributeError:
                    continue  # Should not happen if _get_module_members is correct

                prefix = f"f{i + 1}"
                self._generate_and_write_call(
                    prefix=prefix,
                    callable_name=func_name,
                    callable_obj=func_obj,
                    min_arg_count=1,
                    target_obj_expr="fuzz_target_module",
                    is_method_call=False,
                )
        self.emptyLine()

        # Fuzz classes (instantiate and call methods)
        if self.module_classes:
            self.write_print_to_stderr(
                0,
                f'"--- Fuzzing {len(self.module_classes)} classes in {self.module_name} ---"',
            )
            for i in range(self.options.classes_number):
                if not self.module_classes:
                    break
                class_name = choice(self.module_classes)
                try:
                    class_obj = getattr(self.module, class_name)
                except AttributeError:
                    continue

                self._fuzz_one_class(
                    class_idx=i, class_name_str=class_name, class_type=class_obj
                )
        self.emptyLine()

        if self.module_objects:
            self.write_print_to_stderr(
                0,
                f'"--- Fuzzing {len(self.module_objects)} objects in {self.module_name} ---"',
            )
            for i in range(self.options.objects_number):
                if not self.module_objects:
                    break
                obj_name = choice(self.module_objects)
                if obj_name in OBJECT_BLACKLIST:
                    continue
                try:
                    obj_instance = getattr(self.module, obj_name)
                except AttributeError:
                    continue
                if isinstance(obj_instance, ModuleType):
                    continue

                self._fuzz_one_module_object(
                    obj_idx=i, obj_name_str=obj_name, obj_instance=obj_instance
                )

        self.emptyLine()

    def _fuzz_one_class(self, class_idx: int, class_name_str: str, class_type: type) -> None:
        """Generates code to instantiate a class and fuzz its methods."""
        prefix = f"c{class_idx + 1}"
        instance_var_name = f"instance_{prefix}"
        self.write_print_to_stderr(
            0, f'"[{prefix}] Attempting to instantiate class: {class_name_str}"'
        )

        num_constructor_args = class_arg_number(class_name_str, class_type)

        self.write(0, f"{instance_var_name} = None # Initialize instance variable")
        self.write(0, "try:")
        self.addLevel(1)
        self.write(
            0, f"{instance_var_name} = callFunc('{prefix}_init', '{class_name_str}',"
        )
        self._write_arguments_for_call_lines(num_constructor_args, 1)
        self.write(0, ")")
        if USE_MANGLE_FEATURE:
            self.write(0, mangle_loop % num_constructor_args)
        self.restoreLevel(self.base_level - 1)  # Exit try
        self.write(0, "except Exception as e_instantiate:")
        self.write_print_to_stderr(
            1,
            f'"[{prefix}] Failed to instantiate {class_name_str}: {{e_instantiate.__class__.__name__}}"',
        )
        self.emptyLine()

        self.write(0, f"if {instance_var_name} is not None:")
        current_level = self.addLevel(1)
        methods = self._get_object_methods(class_type, class_name_str)

        if methods:
            self.write_print_to_stderr(
                0,
                f'"[{prefix}] Fuzzing {len(methods)} methods on instance of {class_name_str}"',
            )
            for m_idx in range(self.options.methods_number):
                method_name = choice(list(methods.keys()))
                method_obj = methods[method_name]

                self._generate_and_write_call(
                    prefix=f"{prefix}m{m_idx + 1}",
                    callable_name=method_name,
                    callable_obj=method_obj,
                    min_arg_count=0,
                    target_obj_expr=instance_var_name,
                    is_method_call=True,
                )
        self.write(0, f"del {instance_var_name} # Cleanup instance")
        self.write_print_to_stderr(
            0, f'"[{prefix}] -explicit garbage collection for class instance-"'
        )
        self.write(0, "collect()")
        self.restoreLevel(current_level)
        self.emptyLine()

    def _fuzz_one_module_object(
        self, obj_idx: int, obj_name_str: str, obj_instance: Any
    ) -> None:
        """Generates code to fuzz methods of a given module-level object."""
        prefix = f"obj{obj_idx + 1}"
        obj_expr_in_script = f"fuzz_target_module.{obj_name_str}"

        self.write_print_to_stderr(
            0,
            f'"[{prefix}] Fuzzing methods on module object: {obj_name_str} ({type(obj_instance).__name__})"',
        )

        methods = self._get_object_methods(obj_instance, obj_name_str)
        if methods:
            self.write_print_to_stderr(
                0, f'"[{prefix}] Found {len(methods)} methods for {obj_name_str}"'
            )
            for m_idx in range(self.options.methods_number):
                method_name = choice(list(methods.keys()))
                method_obj = methods[method_name]

                self._generate_and_write_call(
                    prefix=f"{prefix}m{m_idx + 1}",
                    callable_name=method_name,
                    callable_obj=method_obj,
                    min_arg_count=0,
                    target_obj_expr=obj_expr_in_script,
                    is_method_call=True,
                )
        self.write_print_to_stderr(
            0, f'"[{prefix}] -explicit garbage collection for module object bindings-"'
        )
        self.write(0, "collect()")
        self.emptyLine()

    def _write_arguments_for_call_lines(self, num_args: int, base_indent_level: int) -> None:
        """Generates and writes argument lines for a function/method call."""
        for i in range(num_args):
            arg_lines = self.arg_generator.create_complex_argument()
            last_char = "," if i < num_args - 1 else ""

            if not arg_lines:
                self.write(base_indent_level, f"None{last_char} # Empty arg generated")
                continue

            self.write(
                base_indent_level,
                arg_lines[0] + (last_char if len(arg_lines) == 1 else ""),
            )
            for arg_line_part in arg_lines[1:]:
                self.write(
                    base_indent_level,
                    arg_line_part
                    + (last_char if arg_line_part == arg_lines[-1] else ""),
                )

    def _generate_and_write_call(
        self,
        prefix: str,
        callable_name: str,
        callable_obj: Callable[..., Any],
        min_arg_count: int,
        target_obj_expr: str,  # e.g., "fuzz_target_module" or "instance_var"
        is_method_call: bool,
    ) -> None:
        """Generates code for a single function or method call, including async/thread wrappers."""

        if callable_name.lower() in {
            "abort",
            "systemerror",
            "fatal",
            "critical",
            "assert",
        }:
            return

        min_arg, max_arg = get_arg_number(callable_obj, callable_name, min_arg_count)

        rand_choice = randint(0, 19)
        if rand_choice < 1:  # 0 (5%)
            num_args = 0
        elif rand_choice < 2:  # 1 (5%)
            num_args = 1
        elif rand_choice < 3:  # max_arg + 1 (5%)
            num_args = max_arg + 1
        elif min_arg == max_arg:
            num_args = min_arg
        else:  # (remaining 85%)
            num_args = randint(min_arg, max_arg)

        call_prefix = (
            f'callMethod("{prefix}", {target_obj_expr}, "{callable_name}"'
            if is_method_call
            else f'callFunc("{prefix}", "{callable_name}"'
        )

        self.write(0, f"res_{prefix} = {call_prefix},")
        self._write_arguments_for_call_lines(num_args, 1)
        self.write(0, ")")
        self.emptyLine()

        if self.enable_threads:
            self.write(0, "try:")
            self.addLevel(1)
            arg_expr_list = []
            for _ in range(num_args):
                arg_lines = self.arg_generator.create_simple_argument()
                arg_expr_list.append(" ".join(arg_lines))

            args_tuple_str = f"({', '.join(arg_expr_list)}{',' if len(arg_expr_list) == 1 and num_args == 1 else ''})"

            self.write(
                0, f"thread_target_func = getattr({target_obj_expr}, '{callable_name}')"
            )
            self.write(
                0,
                f"thread_obj = Thread(target=thread_target_func, args={args_tuple_str}, name='{prefix}_{callable_name}')",
            )
            self.write(0, "fuzzer_threads_alive.append(thread_obj)")
            self.restoreLevel(self.base_level - 1)
            self.write(0, "except Exception as e_thread_create:")
            self.write_print_to_stderr(
                1,
                f'"[{prefix}] Failed to create thread for {callable_name}: {{e_thread_create.__class__.__name__}}"',
            )
            self.emptyLine()

        if self.enable_async:
            async_func_name = f"async_call_{prefix}_{callable_name}"
            self.write(0, f"def {async_func_name}():")
            self.addLevel(1)
            self.write_print_to_stderr(0, f'"Starting async task: {async_func_name}"')
            self.write(0, f"time.sleep({random.random() / 1000:.6f}) # Small delay")
            self.write(0, "try:")
            self.addLevel(1)
            arg_expr_list_async = []
            for _ in range(num_args):
                arg_lines = self.arg_generator.create_simple_argument()
                arg_expr_list_async.append(" ".join(arg_lines))

            args_str_async = ", ".join(arg_expr_list_async)

            self.write(
                0, f"getattr({target_obj_expr}, '{callable_name}')({args_str_async})"
            )
            self.addLevel(-1)
            self.write(0, "except Exception as e_async_call:")
            self.write_print_to_stderr(
                1,
                f'"[{prefix}] Exception in async task {async_func_name}: {{e_async_call.__class__.__name__}}"',
            )
            self.write_print_to_stderr(0, f'"Ending async task: {async_func_name}"')
            self.addLevel(-1)  # Exit def
            self.write(0, f"fuzzer_async_tasks.append({async_func_name})")
            self.emptyLine()

    def _write_concurrency_finalization(self) -> None:
        """Writes code to start/join threads and run asyncio tasks."""
        if self.enable_threads:
            self.write_print_to_stderr(
                0, '"--- Starting and Joining Fuzzer Threads ---"'
            )
            self.write(0, "for t_obj in fuzzer_threads_alive:")
            self.write(1, "try:")
            self.write_print_to_stderr(2, 'f"Starting thread: {t_obj.name}"')
            self.write(2, "t_obj.start()")
            self.write(1, "except Exception as e_thread_start:")
            self.write_print_to_stderr(
                2,
                'f"Failed to start thread {t_obj.name}: {e_thread_start.__class__.__name__}"',
            )
            self.write(0, "for t_obj in fuzzer_threads_alive:")
            self.write(1, "try:")
            self.write_print_to_stderr(2, 'f"Joining thread: {t_obj.name}"')
            self.write(2, "t_obj.join(timeout=1.0) # Add timeout to join")
            self.write(1, "except Exception as e_thread_join:")
            self.write_print_to_stderr(
                2,
                'f"Failed to join thread {t_obj.name}: {e_thread_join.__class__.__name__}"',
            )
            self.emptyLine()

        if self.enable_async:
            self.write_print_to_stderr(0, '"--- Running Fuzzer Async Tasks ---"')
            self.write(0, "async def main_async_fuzzer_tasks():")
            self.write(1, "if not fuzzer_async_tasks: return")
            self.write(
                1,
                "task_objects = [asyncio.to_thread(func) for func in fuzzer_async_tasks]",
            )
            self.write(1, "await asyncio.gather(*task_objects, return_exceptions=True)")
            self.emptyLine()
            # self.write(0, "asyncio.run(main_async_fuzzer_tasks())") # Python 3.7+
            self.write(0, "runner = asyncio.Runner()")
            self.write(0, "try:")
            self.write(1, "runner.run(main_async_fuzzer_tasks())")
            self.write(0, "finally:")
            self.write(1, "runner.close()")
            self.emptyLine()

    def generate_fuzzing_script(self) -> None:
        """Creates and writes the entire fuzzing script to the specified file."""
        self.createFile(self.generated_filename)

        self._write_script_header_and_imports()
        self._write_tricky_definitions()
        self._write_helper_call_functions()
        self._write_main_fuzzing_logic()
        self._write_concurrency_finalization()

        self.write_print_to_stderr(
            0, f'"--- Fuzzing script generation for {self.module_name} complete ---"'
        )
        self.close()


def remove_logging_pycache() -> None:
    """Remove stale logging __pycache__ that causes logging errors."""
    import importlib
    import logging
    import pathlib

    pycache = pathlib.Path(logging.__file__).parent / "__pycache__"
    for entry in pycache.iterdir():
        try:
            entry.unlink()
        except Exception:
            pass
    try:
        pycache.rmdir()
    except Exception:
        pass
    importlib.reload(logging)


def print_running_time() -> str:
    """Calculate and return a string with total and user running times."""
    raw_utime = resource.getrusage(resource.RUSAGE_SELF).ru_utime
    user_time = str(datetime.timedelta(0, round(raw_utime, 2)))
    total_time = str(datetime.timedelta(0, round(time.time() - time_start, 2)))
    return f"\nRunning time: {total_time[:-4]}\nUser time:    {user_time[:-4]}"


if __name__ == "__main__":
    time_start = time.time()
    remove_logging_pycache()
    Fuzzer().main()
